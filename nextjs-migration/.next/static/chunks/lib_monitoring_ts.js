"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["lib_monitoring_ts"],{

/***/ "./lib/monitoring.ts":
/*!***************************!*\
  !*** ./lib/monitoring.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MonitoringService: function() { return /* binding */ MonitoringService; },\n/* harmony export */   monitoring: function() { return /* binding */ monitoring; }\n/* harmony export */ });\n// Simple throttle function for browser compatibility\nconst throttle = (func, delay)=>{\n    let inThrottle;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!inThrottle) {\n            func.apply(null, args);\n            inThrottle = true;\n            setTimeout(()=>inThrottle = false, delay);\n        }\n    };\n};\nclass MonitoringService {\n    startMonitoring() {\n        if (this.isMonitoring || \"object\" === \"undefined\") return;\n        this.isMonitoring = true;\n        this.initializeMonitoring();\n        console.log(\"\\uD83D\\uDD0D TimeVault monitoring started\");\n    }\n    stopMonitoring() {\n        this.isMonitoring = false;\n        this.monitoringIntervals.forEach((interval)=>clearInterval(interval));\n        this.monitoringIntervals = [];\n        console.log(\"\\uD83D\\uDD0D TimeVault monitoring stopped\");\n    }\n    initializeMonitoring() {\n        if (false) {}\n        // Performance monitoring\n        this.monitorPerformance();\n        // Error monitoring\n        this.monitorErrors();\n        // User behavior monitoring\n        this.monitorUserBehavior();\n        // Resource monitoring\n        this.monitorResources();\n        // Network monitoring\n        this.monitorNetwork();\n    }\n    monitorPerformance() {\n        if (false) {}\n        // Monitor page load times\n        if (document.readyState === \"loading\") {\n            window.addEventListener(\"load\", ()=>{\n                const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;\n                this.recordMetric(\"page_load_time\", loadTime);\n                if (loadTime > 3000) {\n                    this.triggerAlert(\"slow_page_load\", loadTime);\n                }\n            });\n        }\n        // Monitor FPS and frame drops\n        let lastFrameTime = performance.now();\n        let frameCount = 0;\n        let frameTimes = [];\n        const monitorFrame = ()=>{\n            const currentTime = performance.now();\n            const frameTime = currentTime - lastFrameTime;\n            frameCount++;\n            frameTimes.push(frameTime);\n            if (frameTimes.length > 60) frameTimes.shift(); // Keep last 60 frames\n            // Calculate average FPS every second\n            if (frameCount % 60 === 0) {\n                const avgFrameTime = frameTimes.reduce((a, b)=>a + b, 0) / frameTimes.length;\n                const fps = 1000 / avgFrameTime;\n                this.recordMetric(\"fps\", fps);\n                if (fps < 30) {\n                    this.triggerAlert(\"low_fps\", fps);\n                }\n            }\n            lastFrameTime = currentTime;\n            requestAnimationFrame(monitorFrame);\n        };\n        requestAnimationFrame(monitorFrame);\n    }\n    monitorErrors() {\n        if (false) {}\n        window.addEventListener(\"error\", (event)=>{\n            this.recordMetric(\"js_errors\", 1);\n            console.error(\"JS Error:\", event.error);\n        });\n        window.addEventListener(\"unhandledrejection\", (event)=>{\n            this.recordMetric(\"promise_rejections\", 1);\n            console.error(\"Unhandled Promise Rejection:\", event.reason);\n        });\n    }\n    monitorUserBehavior() {\n        if (false) {}\n        // Monitor click interactions\n        document.addEventListener(\"click\", throttle((event)=>{\n            const target = event.target;\n            this.recordMetric(\"user_clicks\", 1);\n            // Track specific interactions\n            if (target.closest(\".nav-tab\")) {\n                this.recordMetric(\"tab_switches\", 1);\n            }\n            if (target.closest(\".calculator-btn\")) {\n                this.recordMetric(\"calculator_usage\", 1);\n            }\n        }, 100));\n        // Monitor scroll behavior\n        window.addEventListener(\"scroll\", throttle(()=>{\n            this.recordMetric(\"scroll_events\", 1);\n        }, 200));\n    }\n    monitorResources() {\n        if (false) {}\n        const interval = setInterval(()=>{\n            // Memory usage monitoring\n            if (\"memory\" in performance) {\n                const memory = performance.memory;\n                const memoryUsage = memory.usedJSHeapSize / memory.jsHeapSizeLimit * 100;\n                this.recordMetric(\"memory_usage\", memoryUsage);\n                if (memoryUsage > 80) {\n                    this.triggerAlert(\"high_memory_usage\", memoryUsage);\n                }\n            }\n            // DOM node count\n            const nodeCount = document.querySelectorAll(\"*\").length;\n            this.recordMetric(\"dom_nodes\", nodeCount);\n            if (nodeCount > 1000) {\n                this.triggerAlert(\"high_dom_count\", nodeCount);\n            }\n        }, 10000); // Every 10 seconds\n        this.monitoringIntervals.push(interval);\n    }\n    monitorNetwork() {\n        var _this = this;\n        if (false) {}\n        // Monitor network requests\n        const originalFetch = window.fetch;\n        window.fetch = async function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            const startTime = performance.now();\n            try {\n                const response = await originalFetch(...args);\n                const endTime = performance.now();\n                const duration = endTime - startTime;\n                _this.recordMetric(\"api_response_time\", duration);\n                _this.recordMetric(\"api_requests\", 1);\n                if (duration > 5000) {\n                    _this.triggerAlert(\"slow_api_response\", duration);\n                }\n                return response;\n            } catch (error) {\n                _this.recordMetric(\"api_errors\", 1);\n                throw error;\n            }\n        };\n    }\n    recordMetric(name, value) {\n        if (!this.metrics.has(name)) {\n            this.metrics.set(name, []);\n        }\n        const values = this.metrics.get(name);\n        values.push(value);\n        // Keep only last 100 values to prevent memory issues\n        if (values.length > 100) {\n            values.shift();\n        }\n    }\n    setAlert(name, threshold, callback) {\n        this.alerts.set(name, {\n            threshold,\n            callback\n        });\n    }\n    triggerAlert(name, value) {\n        const alert = this.alerts.get(name);\n        if (alert && value > alert.threshold) {\n            alert.callback();\n        }\n    }\n    getMetrics() {\n        const result = {};\n        // Convert Map entries to array for compatibility\n        const entries = Array.from(this.metrics.entries());\n        for (const [name, values] of entries){\n            if (values.length > 0) {\n                result[name] = {\n                    current: values[values.length - 1],\n                    average: values.reduce((a, b)=>a + b, 0) / values.length,\n                    min: Math.min(...values),\n                    max: Math.max(...values),\n                    count: values.length\n                };\n            }\n        }\n        return result;\n    }\n    generateReport() {\n        const metrics = this.getMetrics();\n        const report = [\n            \"\\uD83D\\uDD0D TimeVault Performance Report\",\n            \"\"\n        ];\n        for (const [name, data] of Object.entries(metrics)){\n            report.push(\"\".concat(name, \": Current \").concat(data.current, \", Avg \").concat(data.average.toFixed(2)));\n        }\n        return report.join(\"\\\\n\");\n    }\n    constructor(){\n        this.metrics = new Map();\n        this.alerts = new Map();\n        this.isMonitoring = false;\n        this.monitoringIntervals = [];\n    }\n}\nconst monitoring = new MonitoringService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSUMsT0FBT1osT0FBTyxDQUFDWixTQUFVO1lBQ2hEc0IsT0FBT25ELElBQUksQ0FBQyxHQUFvQm9ELE9BQWpCekIsTUFBSyxjQUFpQ3lCLE9BQXJCQSxLQUFLUixPQUFPLEVBQUMsVUFBZ0MsT0FBeEJRLEtBQUtQLE9BQU8sQ0FBQ1MsT0FBTyxDQUFDO1FBQzlFO1FBRUEsT0FBT0gsT0FBT0ksSUFBSSxDQUFDO0lBQ3ZCOzthQW5PaUIxQixVQUFVLElBQUkyQjthQUNkbkIsU0FBUyxJQUFJbUI7YUFDdkJ4RixlQUFlO2FBQ2RLLHNCQUF3QyxFQUFFOztBQWlPdEQ7QUFFTyxNQUFNb0YsYUFBYSxJQUFJM0Ysb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9tb25pdG9yaW5nLnRzPzdhZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2ltcGxlIHRocm90dGxlIGZ1bmN0aW9uIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHlcclxuY29uc3QgdGhyb3R0bGUgPSA8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihmdW5jOiBULCBkZWxheTogbnVtYmVyKTogKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHZvaWQgPT4ge1xyXG4gICAgbGV0IGluVGhyb3R0bGU6IGJvb2xlYW47XHJcbiAgICByZXR1cm4gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHtcclxuICAgICAgICBpZiAoIWluVGhyb3R0bGUpIHtcclxuICAgICAgICAgICAgZnVuYy5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICAgICAgaW5UaHJvdHRsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gaW5UaHJvdHRsZSA9IGZhbHNlLCBkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBNb25pdG9yaW5nU2VydmljZSB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1ldHJpY3MgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyW10+KCk7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsZXJ0cyA9IG5ldyBNYXA8c3RyaW5nLCB7IHRocmVzaG9sZDogbnVtYmVyOyBjYWxsYmFjazogKCkgPT4gdm9pZCB9PigpO1xyXG4gICAgcHVibGljIGlzTW9uaXRvcmluZyA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBtb25pdG9yaW5nSW50ZXJ2YWxzOiBOb2RlSlMuVGltZW91dFtdID0gW107XHJcblxyXG4gICAgc3RhcnRNb25pdG9yaW5nKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTW9uaXRvcmluZyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmlzTW9uaXRvcmluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplTW9uaXRvcmluZygpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFRpbWVWYXVsdCBtb25pdG9yaW5nIHN0YXJ0ZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBzdG9wTW9uaXRvcmluZygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmlzTW9uaXRvcmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW9uaXRvcmluZ0ludGVydmFscy5mb3JFYWNoKGludGVydmFsID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpKTtcclxuICAgICAgICB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbHMgPSBbXTtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBUaW1lVmF1bHQgbW9uaXRvcmluZyBzdG9wcGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplTW9uaXRvcmluZygpOiB2b2lkIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xyXG4gICAgICAgIHRoaXMubW9uaXRvclBlcmZvcm1hbmNlKCk7XHJcbiAgICAgICAgLy8gRXJyb3IgbW9uaXRvcmluZ1xyXG4gICAgICAgIHRoaXMubW9uaXRvckVycm9ycygpO1xyXG4gICAgICAgIC8vIFVzZXIgYmVoYXZpb3IgbW9uaXRvcmluZ1xyXG4gICAgICAgIHRoaXMubW9uaXRvclVzZXJCZWhhdmlvcigpO1xyXG4gICAgICAgIC8vIFJlc291cmNlIG1vbml0b3JpbmdcclxuICAgICAgICB0aGlzLm1vbml0b3JSZXNvdXJjZXMoKTtcclxuICAgICAgICAvLyBOZXR3b3JrIG1vbml0b3JpbmdcclxuICAgICAgICB0aGlzLm1vbml0b3JOZXR3b3JrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBtb25pdG9yUGVyZm9ybWFuY2UoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIE1vbml0b3IgcGFnZSBsb2FkIHRpbWVzXHJcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRUaW1lID0gcGVyZm9ybWFuY2UudGltaW5nLmxvYWRFdmVudEVuZCAtIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygncGFnZV9sb2FkX3RpbWUnLCBsb2FkVGltZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxvYWRUaW1lID4gMzAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckFsZXJ0KCdzbG93X3BhZ2VfbG9hZCcsIGxvYWRUaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNb25pdG9yIEZQUyBhbmQgZnJhbWUgZHJvcHNcclxuICAgICAgICBsZXQgbGFzdEZyYW1lVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGxldCBmcmFtZUNvdW50ID0gMDtcclxuICAgICAgICBsZXQgZnJhbWVUaW1lczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICAgICAgY29uc3QgbW9uaXRvckZyYW1lID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICBjb25zdCBmcmFtZVRpbWUgPSBjdXJyZW50VGltZSAtIGxhc3RGcmFtZVRpbWU7XHJcbiAgICAgICAgICAgIGZyYW1lQ291bnQrKztcclxuXHJcbiAgICAgICAgICAgIGZyYW1lVGltZXMucHVzaChmcmFtZVRpbWUpO1xyXG4gICAgICAgICAgICBpZiAoZnJhbWVUaW1lcy5sZW5ndGggPiA2MCkgZnJhbWVUaW1lcy5zaGlmdCgpOyAvLyBLZWVwIGxhc3QgNjAgZnJhbWVzXHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgYXZlcmFnZSBGUFMgZXZlcnkgc2Vjb25kXHJcbiAgICAgICAgICAgIGlmIChmcmFtZUNvdW50ICUgNjAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF2Z0ZyYW1lVGltZSA9IGZyYW1lVGltZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBmcmFtZVRpbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZwcyA9IDEwMDAgLyBhdmdGcmFtZVRpbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygnZnBzJywgZnBzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZnBzIDwgMzApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJBbGVydCgnbG93X2ZwcycsIGZwcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxhc3RGcmFtZVRpbWUgPSBjdXJyZW50VGltZTtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vbml0b3JGcmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vbml0b3JGcmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBtb25pdG9yRXJyb3JzKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWMoJ2pzX2Vycm9ycycsIDEpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdKUyBFcnJvcjonLCBldmVudC5lcnJvcik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWMoJ3Byb21pc2VfcmVqZWN0aW9ucycsIDEpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246JywgZXZlbnQucmVhc29uKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1vbml0b3JVc2VyQmVoYXZpb3IoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIE1vbml0b3IgY2xpY2sgaW50ZXJhY3Rpb25zXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aHJvdHRsZSgoZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWMoJ3VzZXJfY2xpY2tzJywgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUcmFjayBzcGVjaWZpYyBpbnRlcmFjdGlvbnNcclxuICAgICAgICAgICAgaWYgKHRhcmdldC5jbG9zZXN0KCcubmF2LXRhYicpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygndGFiX3N3aXRjaGVzJywgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuY2FsY3VsYXRvci1idG4nKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWMoJ2NhbGN1bGF0b3JfdXNhZ2UnLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDEwMCkpO1xyXG5cclxuICAgICAgICAvLyBNb25pdG9yIHNjcm9sbCBiZWhhdmlvclxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aHJvdHRsZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb3JkTWV0cmljKCdzY3JvbGxfZXZlbnRzJywgMSk7XHJcbiAgICAgICAgfSwgMjAwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBtb25pdG9yUmVzb3VyY2VzKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gTWVtb3J5IHVzYWdlIG1vbml0b3JpbmdcclxuICAgICAgICAgICAgaWYgKCdtZW1vcnknIGluIHBlcmZvcm1hbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZW1vcnlVc2FnZSA9IG1lbW9yeS51c2VkSlNIZWFwU2l6ZSAvIG1lbW9yeS5qc0hlYXBTaXplTGltaXQgKiAxMDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygnbWVtb3J5X3VzYWdlJywgbWVtb3J5VXNhZ2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtZW1vcnlVc2FnZSA+IDgwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQWxlcnQoJ2hpZ2hfbWVtb3J5X3VzYWdlJywgbWVtb3J5VXNhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBET00gbm9kZSBjb3VudFxyXG4gICAgICAgICAgICBjb25zdCBub2RlQ291bnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygnZG9tX25vZGVzJywgbm9kZUNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChub2RlQ291bnQgPiAxMDAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJBbGVydCgnaGlnaF9kb21fY291bnQnLCBub2RlQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMTAwMDApOyAvLyBFdmVyeSAxMCBzZWNvbmRzXHJcblxyXG4gICAgICAgIHRoaXMubW9uaXRvcmluZ0ludGVydmFscy5wdXNoKGludGVydmFsKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1vbml0b3JOZXR3b3JrKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBNb25pdG9yIG5ldHdvcmsgcmVxdWVzdHNcclxuICAgICAgICBjb25zdCBvcmlnaW5hbEZldGNoID0gd2luZG93LmZldGNoO1xyXG4gICAgICAgIHdpbmRvdy5mZXRjaCA9IGFzeW5jICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcmlnaW5hbEZldGNoKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkTWV0cmljKCdhcGlfcmVzcG9uc2VfdGltZScsIGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkTWV0cmljKCdhcGlfcmVxdWVzdHMnLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPiA1MDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQWxlcnQoJ3Nsb3dfYXBpX3Jlc3BvbnNlJywgZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkTWV0cmljKCdhcGlfZXJyb3JzJywgMSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmVjb3JkTWV0cmljKG5hbWU6IHN0cmluZywgdmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5tZXRyaWNzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1ldHJpY3Muc2V0KG5hbWUsIFtdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMubWV0cmljcy5nZXQobmFtZSkhO1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuXHJcbiAgICAgICAgLy8gS2VlcCBvbmx5IGxhc3QgMTAwIHZhbHVlcyB0byBwcmV2ZW50IG1lbW9yeSBpc3N1ZXNcclxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDEwMCkge1xyXG4gICAgICAgICAgICB2YWx1ZXMuc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0QWxlcnQobmFtZTogc3RyaW5nLCB0aHJlc2hvbGQ6IG51bWJlciwgY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFsZXJ0cy5zZXQobmFtZSwgeyB0aHJlc2hvbGQsIGNhbGxiYWNrIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdHJpZ2dlckFsZXJ0KG5hbWU6IHN0cmluZywgdmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGFsZXJ0ID0gdGhpcy5hbGVydHMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIGlmIChhbGVydCAmJiB2YWx1ZSA+IGFsZXJ0LnRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICBhbGVydC5jYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRNZXRyaWNzKCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IE1hcCBlbnRyaWVzIHRvIGFycmF5IGZvciBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgY29uc3QgZW50cmllcyA9IEFycmF5LmZyb20odGhpcy5tZXRyaWNzLmVudHJpZXMoKSk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlc10gb2YgZW50cmllcykge1xyXG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2U6IHZhbHVlcy5yZWR1Y2UoKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBhICsgYiwgMCkgLyB2YWx1ZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbjogTWF0aC5taW4oLi4udmFsdWVzKSxcclxuICAgICAgICAgICAgICAgICAgICBtYXg6IE1hdGgubWF4KC4uLnZhbHVlcyksXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IHZhbHVlcy5sZW5ndGhcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2VuZXJhdGVSZXBvcnQoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBtZXRyaWNzID0gdGhpcy5nZXRNZXRyaWNzKCk7XHJcbiAgICAgICAgY29uc3QgcmVwb3J0ID0gWyfwn5SNIFRpbWVWYXVsdCBQZXJmb3JtYW5jZSBSZXBvcnQnLCAnJ107XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIGRhdGFdIG9mIE9iamVjdC5lbnRyaWVzKG1ldHJpY3MpKSB7XHJcbiAgICAgICAgICAgIHJlcG9ydC5wdXNoKGAke25hbWV9OiBDdXJyZW50ICR7ZGF0YS5jdXJyZW50fSwgQXZnICR7ZGF0YS5hdmVyYWdlLnRvRml4ZWQoMil9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVwb3J0LmpvaW4oJ1xcXFxuJyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBtb25pdG9yaW5nID0gbmV3IE1vbml0b3JpbmdTZXJ2aWNlKCk7XHJcbiJdLCJuYW1lcyI6WyJ0aHJvdHRsZSIsImZ1bmMiLCJkZWxheSIsImluVGhyb3R0bGUiLCJhcmdzIiwiYXBwbHkiLCJzZXRUaW1lb3V0IiwiTW9uaXRvcmluZ1NlcnZpY2UiLCJzdGFydE1vbml0b3JpbmciLCJpc01vbml0b3JpbmciLCJpbml0aWFsaXplTW9uaXRvcmluZyIsImNvbnNvbGUiLCJsb2ciLCJzdG9wTW9uaXRvcmluZyIsIm1vbml0b3JpbmdJbnRlcnZhbHMiLCJmb3JFYWNoIiwiaW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwibW9uaXRvclBlcmZvcm1hbmNlIiwibW9uaXRvckVycm9ycyIsIm1vbml0b3JVc2VyQmVoYXZpb3IiLCJtb25pdG9yUmVzb3VyY2VzIiwibW9uaXRvck5ldHdvcmsiLCJkb2N1bWVudCIsInJlYWR5U3RhdGUiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwibG9hZFRpbWUiLCJwZXJmb3JtYW5jZSIsInRpbWluZyIsImxvYWRFdmVudEVuZCIsIm5hdmlnYXRpb25TdGFydCIsInJlY29yZE1ldHJpYyIsInRyaWdnZXJBbGVydCIsImxhc3RGcmFtZVRpbWUiLCJub3ciLCJmcmFtZUNvdW50IiwiZnJhbWVUaW1lcyIsIm1vbml0b3JGcmFtZSIsImN1cnJlbnRUaW1lIiwiZnJhbWVUaW1lIiwicHVzaCIsImxlbmd0aCIsInNoaWZ0IiwiYXZnRnJhbWVUaW1lIiwicmVkdWNlIiwiYSIsImIiLCJmcHMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJldmVudCIsImVycm9yIiwicmVhc29uIiwidGFyZ2V0IiwiY2xvc2VzdCIsInNldEludGVydmFsIiwibWVtb3J5IiwibWVtb3J5VXNhZ2UiLCJ1c2VkSlNIZWFwU2l6ZSIsImpzSGVhcFNpemVMaW1pdCIsIm5vZGVDb3VudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvcmlnaW5hbEZldGNoIiwiZmV0Y2giLCJzdGFydFRpbWUiLCJyZXNwb25zZSIsImVuZFRpbWUiLCJkdXJhdGlvbiIsIm5hbWUiLCJ2YWx1ZSIsIm1ldHJpY3MiLCJoYXMiLCJzZXQiLCJ2YWx1ZXMiLCJnZXQiLCJzZXRBbGVydCIsInRocmVzaG9sZCIsImNhbGxiYWNrIiwiYWxlcnRzIiwiYWxlcnQiLCJnZXRNZXRyaWNzIiwicmVzdWx0IiwiZW50cmllcyIsIkFycmF5IiwiZnJvbSIsImN1cnJlbnQiLCJhdmVyYWdlIiwibWluIiwiTWF0aCIsIm1heCIsImNvdW50IiwiZ2VuZXJhdGVSZXBvcnQiLCJyZXBvcnQiLCJkYXRhIiwiT2JqZWN0IiwidG9GaXhlZCIsImpvaW4iLCJNYXAiLCJtb25pdG9yaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/monitoring.ts\n"));

/***/ })

}]);