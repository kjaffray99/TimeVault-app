"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ App; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tanstack/react-query */ \"./node_modules/@tanstack/react-query/build/modern/index.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _services_analyticsEnhanced__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../services/analyticsEnhanced */ \"./services/analyticsEnhanced.ts\");\n/* harmony import */ var _services_monitoringService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../services/monitoringService */ \"./services/monitoringService.ts\");\n/* harmony import */ var _styles_day1_app_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/day1-app.css */ \"./styles/day1-app.css\");\n/* harmony import */ var _styles_day1_app_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_day1_app_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _styles_gamification_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../styles/gamification.css */ \"./styles/gamification.css\");\n/* harmony import */ var _styles_gamification_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_styles_gamification_css__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_7__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n// Create optimized QueryClient for SSR\nfunction createQueryClient() {\n    return new _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.QueryClient({\n        defaultOptions: {\n            queries: {\n                gcTime: 5 * 60 * 1000,\n                staleTime: 30 * 1000,\n                retry: 2,\n                refetchOnWindowFocus: false,\n                refetchOnReconnect: true\n            },\n            mutations: {\n                retry: 1\n            }\n        }\n    });\n}\nfunction App(param) {\n    let { Component, pageProps } = param;\n    _s();\n    const [queryClient] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(()=>createQueryClient());\n    // Performance monitoring initialization\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        // Initialize analytics and monitoring in client\n        if (true) {\n            try {\n                // Initialize monitoring system\n                _services_monitoringService__WEBPACK_IMPORTED_MODULE_4__.monitoring.startMonitoring();\n                // Set up performance alerts\n                _services_monitoringService__WEBPACK_IMPORTED_MODULE_4__.monitoring.setAlert(\"slow_page_load\", 3000, ()=>{\n                    _services_analyticsEnhanced__WEBPACK_IMPORTED_MODULE_3__.analytics.trackEvent(\"performance_alert\", {\n                        category: \"performance\",\n                        alert_type: \"slow_page_load\"\n                    });\n                });\n                // Track app initialization\n                _services_analyticsEnhanced__WEBPACK_IMPORTED_MODULE_3__.analytics.trackEvent(\"app_initialized\", {\n                    category: \"app_lifecycle\",\n                    timestamp: Date.now(),\n                    version: \"2.0-nextjs\"\n                });\n                console.log(\"✅ TimeVault optimization systems initialized\");\n            } catch (error) {\n                console.error(\"❌ Failed to initialize optimization systems:\", error);\n            }\n        }\n        // Cleanup on unmount\n        return ()=>{\n            if (true) {\n                _services_monitoringService__WEBPACK_IMPORTED_MODULE_4__.monitoring.stopMonitoring();\n                _services_analyticsEnhanced__WEBPACK_IMPORTED_MODULE_3__.analytics.destroy();\n            }\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.QueryClientProvider, {\n        client: queryClient,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                    name: \"viewport\",\n                    content: \"width=device-width, initial-scale=1\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\kjaff\\\\OneDrive\\\\Desktop\\\\TimeVault\\\\nextjs-migration\\\\pages\\\\_app.tsx\",\n                    lineNumber: 73,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\kjaff\\\\OneDrive\\\\Desktop\\\\TimeVault\\\\nextjs-migration\\\\pages\\\\_app.tsx\",\n                lineNumber: 72,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                ...pageProps\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\kjaff\\\\OneDrive\\\\Desktop\\\\TimeVault\\\\nextjs-migration\\\\pages\\\\_app.tsx\",\n                lineNumber: 75,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\kjaff\\\\OneDrive\\\\Desktop\\\\TimeVault\\\\nextjs-migration\\\\pages\\\\_app.tsx\",\n        lineNumber: 71,\n        columnNumber: 9\n    }, this);\n}\n_s(App, \"lwV4W6/zpiIaZ1iDxgEhNj/0C4w=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUU7QUFFNUM7QUFDZTtBQUNjO0FBQ0M7QUFDM0I7QUFDSTtBQUNMO0FBRS9CLHVDQUF1QztBQUN2QyxTQUFTTztJQUNMLE9BQU8sSUFBSVAsOERBQVdBLENBQUM7UUFDbkJRLGdCQUFnQjtZQUNaQyxTQUFTO2dCQUNMQyxRQUFRLElBQUksS0FBSztnQkFDakJDLFdBQVcsS0FBSztnQkFDaEJDLE9BQU87Z0JBQ1BDLHNCQUFzQjtnQkFDdEJDLG9CQUFvQjtZQUN4QjtZQUNBQyxXQUFXO2dCQUNQSCxPQUFPO1lBQ1g7UUFDSjtJQUNKO0FBQ0o7QUFFZSxTQUFTSSxJQUFJLEtBQWtDO1FBQWxDLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFZLEdBQWxDOztJQUN4QixNQUFNLENBQUNDLFlBQVksR0FBR2YsK0NBQVFBLENBQUMsSUFBTUc7SUFFckMsd0NBQXdDO0lBQ3hDSixnREFBU0EsQ0FBQztRQUNOLGdEQUFnRDtRQUNoRCxJQUFJLElBQWtCLEVBQWE7WUFDL0IsSUFBSTtnQkFDQSwrQkFBK0I7Z0JBQy9CRyxtRUFBVUEsQ0FBQ2MsZUFBZTtnQkFFMUIsNEJBQTRCO2dCQUM1QmQsbUVBQVVBLENBQUNlLFFBQVEsQ0FBQyxrQkFBa0IsTUFBTTtvQkFDeENoQixrRUFBU0EsQ0FBQ2lCLFVBQVUsQ0FBQyxxQkFBcUI7d0JBQ3RDQyxVQUFVO3dCQUNWQyxZQUFZO29CQUNoQjtnQkFDSjtnQkFFQSwyQkFBMkI7Z0JBQzNCbkIsa0VBQVNBLENBQUNpQixVQUFVLENBQUMsbUJBQW1CO29CQUNwQ0MsVUFBVTtvQkFDVkUsV0FBV0MsS0FBS0MsR0FBRztvQkFDbkJDLFNBQVM7Z0JBQ2I7Z0JBRUFDLFFBQVFDLEdBQUcsQ0FBQztZQUNoQixFQUFFLE9BQU9DLE9BQU87Z0JBQ1pGLFFBQVFFLEtBQUssQ0FBQyxnREFBZ0RBO1lBQ2xFO1FBQ0o7UUFFQSxxQkFBcUI7UUFDckIsT0FBTztZQUNILElBQUksSUFBa0IsRUFBYTtnQkFDL0J6QixtRUFBVUEsQ0FBQzBCLGNBQWM7Z0JBQ3pCM0Isa0VBQVNBLENBQUM0QixPQUFPO1lBQ3JCO1FBQ0o7SUFDSixHQUFHLEVBQUU7SUFFTCxxQkFDSSw4REFBQ2hDLHNFQUFtQkE7UUFBQ2lDLFFBQVFmOzswQkFDekIsOERBQUNqQixrREFBSUE7MEJBQ0QsNEVBQUNpQztvQkFBS0MsTUFBSztvQkFBV0MsU0FBUTs7Ozs7Ozs7Ozs7MEJBRWxDLDhEQUFDcEI7Z0JBQVcsR0FBR0MsU0FBUzs7Ozs7Ozs7Ozs7O0FBR3BDO0dBakR3QkY7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvX2FwcC50c3g/MmZiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBRdWVyeUNsaWVudCwgUXVlcnlDbGllbnRQcm92aWRlciB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSc7XHJcbmltcG9ydCB0eXBlIHsgQXBwUHJvcHMgfSBmcm9tICduZXh0L2FwcCc7XHJcbmltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGFuYWx5dGljcyB9IGZyb20gJy4uL3NlcnZpY2VzL2FuYWx5dGljc0VuaGFuY2VkJztcclxuaW1wb3J0IHsgbW9uaXRvcmluZyB9IGZyb20gJy4uL3NlcnZpY2VzL21vbml0b3JpbmdTZXJ2aWNlJztcclxuaW1wb3J0ICcuLi9zdHlsZXMvZGF5MS1hcHAuY3NzJztcclxuaW1wb3J0ICcuLi9zdHlsZXMvZ2FtaWZpY2F0aW9uLmNzcyc7XHJcbmltcG9ydCAnLi4vc3R5bGVzL2dsb2JhbHMuY3NzJztcclxuXHJcbi8vIENyZWF0ZSBvcHRpbWl6ZWQgUXVlcnlDbGllbnQgZm9yIFNTUlxyXG5mdW5jdGlvbiBjcmVhdGVRdWVyeUNsaWVudCgpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlDbGllbnQoe1xyXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHF1ZXJpZXM6IHtcclxuICAgICAgICAgICAgICAgIGdjVGltZTogNSAqIDYwICogMTAwMCwgLy8gNSBtaW51dGVzXHJcbiAgICAgICAgICAgICAgICBzdGFsZVRpbWU6IDMwICogMTAwMCwgLy8gMzAgc2Vjb25kc1xyXG4gICAgICAgICAgICAgICAgcmV0cnk6IDIsXHJcbiAgICAgICAgICAgICAgICByZWZldGNoT25XaW5kb3dGb2N1czogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZWZldGNoT25SZWNvbm5lY3Q6IHRydWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG11dGF0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgcmV0cnk6IDEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9OiBBcHBQcm9wcykge1xyXG4gICAgY29uc3QgW3F1ZXJ5Q2xpZW50XSA9IHVzZVN0YXRlKCgpID0+IGNyZWF0ZVF1ZXJ5Q2xpZW50KCkpO1xyXG5cclxuICAgIC8vIFBlcmZvcm1hbmNlIG1vbml0b3JpbmcgaW5pdGlhbGl6YXRpb25cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbmFseXRpY3MgYW5kIG1vbml0b3JpbmcgaW4gY2xpZW50XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIG1vbml0b3Jpbmcgc3lzdGVtXHJcbiAgICAgICAgICAgICAgICBtb25pdG9yaW5nLnN0YXJ0TW9uaXRvcmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNldCB1cCBwZXJmb3JtYW5jZSBhbGVydHNcclxuICAgICAgICAgICAgICAgIG1vbml0b3Jpbmcuc2V0QWxlcnQoJ3Nsb3dfcGFnZV9sb2FkJywgMzAwMCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuYWx5dGljcy50cmFja0V2ZW50KCdwZXJmb3JtYW5jZV9hbGVydCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6ICdwZXJmb3JtYW5jZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0X3R5cGU6ICdzbG93X3BhZ2VfbG9hZCdcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIGFwcCBpbml0aWFsaXphdGlvblxyXG4gICAgICAgICAgICAgICAgYW5hbHl0aWNzLnRyYWNrRXZlbnQoJ2FwcF9pbml0aWFsaXplZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeTogJ2FwcF9saWZlY3ljbGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMi4wLW5leHRqcydcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgVGltZVZhdWx0IG9wdGltaXphdGlvbiBzeXN0ZW1zIGluaXRpYWxpemVkJyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGluaXRpYWxpemUgb3B0aW1pemF0aW9uIHN5c3RlbXM6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGVhbnVwIG9uIHVubW91bnRcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG1vbml0b3Jpbmcuc3RvcE1vbml0b3JpbmcoKTtcclxuICAgICAgICAgICAgICAgIGFuYWx5dGljcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFF1ZXJ5Q2xpZW50UHJvdmlkZXIgY2xpZW50PXtxdWVyeUNsaWVudH0+XHJcbiAgICAgICAgICAgIDxIZWFkPlxyXG4gICAgICAgICAgICAgICAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xXCIgLz5cclxuICAgICAgICAgICAgPC9IZWFkPlxyXG4gICAgICAgICAgICA8Q29tcG9uZW50IHsuLi5wYWdlUHJvcHN9IC8+XHJcbiAgICAgICAgPC9RdWVyeUNsaWVudFByb3ZpZGVyPlxyXG4gICAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiUXVlcnlDbGllbnQiLCJRdWVyeUNsaWVudFByb3ZpZGVyIiwiSGVhZCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiYW5hbHl0aWNzIiwibW9uaXRvcmluZyIsImNyZWF0ZVF1ZXJ5Q2xpZW50IiwiZGVmYXVsdE9wdGlvbnMiLCJxdWVyaWVzIiwiZ2NUaW1lIiwic3RhbGVUaW1lIiwicmV0cnkiLCJyZWZldGNoT25XaW5kb3dGb2N1cyIsInJlZmV0Y2hPblJlY29ubmVjdCIsIm11dGF0aW9ucyIsIkFwcCIsIkNvbXBvbmVudCIsInBhZ2VQcm9wcyIsInF1ZXJ5Q2xpZW50Iiwic3RhcnRNb25pdG9yaW5nIiwic2V0QWxlcnQiLCJ0cmFja0V2ZW50IiwiY2F0ZWdvcnkiLCJhbGVydF90eXBlIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInZlcnNpb24iLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJzdG9wTW9uaXRvcmluZyIsImRlc3Ryb3kiLCJjbGllbnQiLCJtZXRhIiwibmFtZSIsImNvbnRlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/_app.tsx\n"));

/***/ }),

/***/ "./services/analyticsEnhanced.ts":
/*!***************************************!*\
  !*** ./services/analyticsEnhanced.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalyticsEnhanced: function() { return /* binding */ AnalyticsEnhanced; },\n/* harmony export */   analytics: function() { return /* binding */ analytics; }\n/* harmony export */ });\nclass AnalyticsEnhanced {\n    generateUserId() {\n        if (false) {}\n        let userId = localStorage.getItem(\"timevault_user_id\");\n        if (!userId) {\n            userId = crypto.randomUUID();\n            localStorage.setItem(\"timevault_user_id\", userId);\n        }\n        return userId;\n    }\n    initializeSession() {\n        if (false) {}\n        this.trackEvent(\"session_start\", {\n            user_agent: navigator.userAgent,\n            screen_resolution: \"\".concat(screen.width, \"x\").concat(screen.height),\n            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n            language: navigator.language,\n            platform: navigator.platform\n        });\n    }\n    setupAutoFlush() {\n        // Flush events every 30 seconds\n        this.flushTimer = setInterval(()=>{\n            if (this.events.length > 0) {\n                this.flushEvents();\n            }\n        }, 30000);\n        // Flush on page unload\n        if (true) {\n            window.addEventListener(\"beforeunload\", ()=>{\n                this.flushEvents();\n            });\n        }\n    }\n    trackEvent(event) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const eventData = {\n            event,\n            data: {\n                ...data,\n                session_id: this.sessionId,\n                user_id: this.userId,\n                timestamp: Date.now(),\n                page_url:  true ? window.location.href : 0\n            },\n            timestamp: Date.now()\n        };\n        this.events.push(eventData);\n        // Send to Google Analytics if available\n        if ( true && window.gtag) {\n            window.gtag(\"event\", event, {\n                event_category: data.category || \"user_interaction\",\n                event_label: data.label || \"\",\n                value: data.value || 0,\n                custom_parameters: data\n            });\n        }\n        // Batch send to backend every 10 events\n        if (this.events.length >= 10) {\n            this.flushEvents();\n        }\n    }\n    async flushEvents() {\n        if (this.events.length === 0) return;\n        const eventsToSend = [\n            ...this.events\n        ];\n        this.events.length = 0;\n        try {\n            // Only attempt to send if we're in browser environment\n            if (true) {\n                await fetch(\"/api/analytics/events\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify(eventsToSend)\n                });\n            }\n        } catch (error) {\n            console.warn(\"Failed to send analytics events:\", error);\n            // Re-add failed events back to queue (up to a limit)\n            if (this.events.length < 50) {\n                this.events.unshift(...eventsToSend);\n            }\n        }\n    }\n    // Customer Experience specific tracking\n    trackUserJourney(step) {\n        let metadata = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        this.trackEvent(\"user_journey\", {\n            category: \"ux\",\n            step,\n            ...metadata\n        });\n    }\n    trackPerformance(metric, value) {\n        let context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        this.trackEvent(\"performance_metric\", {\n            category: \"performance\",\n            metric,\n            value,\n            ...context\n        });\n    }\n    trackError(error) {\n        let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        this.trackEvent(\"error\", {\n            category: \"error\",\n            message: error.message,\n            stack: error.stack,\n            ...context\n        });\n    }\n    // Customer satisfaction tracking\n    trackSatisfaction(rating) {\n        let feedback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        this.trackEvent(\"satisfaction_rating\", {\n            category: \"cx\",\n            rating,\n            feedback,\n            ...context\n        });\n    }\n    // Enhanced user behavior tracking\n    trackConversion(type) {\n        let value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, metadata = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        this.trackEvent(\"conversion\", {\n            category: \"conversion\",\n            conversion_type: type,\n            value,\n            ...metadata\n        });\n    }\n    trackEngagement(action) {\n        let duration = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, metadata = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        this.trackEvent(\"engagement\", {\n            category: \"engagement\",\n            action,\n            duration,\n            ...metadata\n        });\n    }\n    // Utility methods\n    isTrackingEnabled() {\n        return  true && !navigator.doNotTrack;\n    }\n    getUserBehaviorPattern() {\n        // This would analyze user behavior patterns\n        // For now, return mock data\n        return {\n            likelyToUseQuiz: Math.random() > 0.5,\n            likelyToUpgrade: Math.random() > 0.7,\n            engagementLevel: \"high\",\n            preferredFeatures: [\n                \"calculator\",\n                \"quiz\"\n            ]\n        };\n    }\n    getSessionData() {\n        return {\n            sessionId: this.sessionId,\n            userId: this.userId,\n            eventsQueued: this.events.length\n        };\n    }\n    // Cleanup method\n    destroy() {\n        if (this.flushTimer) {\n            clearInterval(this.flushTimer);\n        }\n        this.flushEvents();\n    }\n    constructor(){\n        this.events = [];\n        this.sessionId = crypto.randomUUID();\n        this.flushTimer = null;\n        this.userId = this.generateUserId();\n        this.initializeSession();\n        this.setupAutoFlush();\n    }\n}\nconst analytics = new AnalyticsEnhanced();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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MUNDLFdBQUFBLGlFQUFtQixHQUFHZixXQUFBQSxpRUFBZ0IsQ0FBQztRQUNuRSxJQUFJLENBQUN4RCxVQUFVLENBQUMsY0FBYztZQUMxQnNDLFVBQVU7WUFDVmdDO1lBQ0FDO1lBQ0EsR0FBR2YsUUFBUTtRQUNmO0lBQ0o7SUFFQSxrQkFBa0I7SUFDbEJnQixvQkFBNkI7UUFDekIsT0FBTyxLQUFrQixJQUFlLENBQUN0RSxVQUFVdUUsVUFBVTtJQUNqRTtJQUVBQyx5QkFBeUI7UUFDckIsNENBQTRDO1FBQzVDLDRCQUE0QjtRQUM1QixPQUFPO1lBQ0hDLGlCQUFpQkMsS0FBS0MsTUFBTSxLQUFLO1lBQ2pDQyxpQkFBaUJGLEtBQUtDLE1BQU0sS0FBSztZQUNqQ0UsaUJBQWlCO1lBQ2pCQyxtQkFBbUI7Z0JBQUM7Z0JBQWM7YUFBTztRQUM3QztJQUNKO0lBRUFDLGlCQUFpQjtRQUNiLE9BQU87WUFDSHRELFdBQVcsSUFBSSxDQUFDQSxTQUFTO1lBQ3pCbEMsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJ5RixjQUFjLElBQUksQ0FBQ2hFLE1BQU0sQ0FBQ0MsTUFBTTtRQUNwQztJQUNKO0lBRUEsaUJBQWlCO0lBQ2pCZ0UsVUFBVTtRQUNOLElBQUksSUFBSSxDQUFDbkUsVUFBVSxFQUFFO1lBQ2pCb0UsY0FBYyxJQUFJLENBQUNwRSxVQUFVO1FBQ2pDO1FBQ0EsSUFBSSxDQUFDSSxXQUFXO0lBQ3BCO0lBMUxBaUUsYUFBYzthQUxHbkUsU0FBaUUsRUFBRTthQUNuRVMsWUFBb0IvQixPQUFPQyxVQUFVO2FBRTlDbUIsYUFBb0M7UUFHeEMsSUFBSSxDQUFDdkIsTUFBTSxHQUFHLElBQUksQ0FBQ0QsY0FBYztRQUNqQyxJQUFJLENBQUNPLGlCQUFpQjtRQUN0QixJQUFJLENBQUNnQixjQUFjO0lBQ3ZCO0FBdUxKO0FBRU8sTUFBTXVFLFlBQVksSUFBSS9GLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zZXJ2aWNlcy9hbmFseXRpY3NFbmhhbmNlZC50cz9iZGU2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBBbmFseXRpY3NFbmhhbmNlZCB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV2ZW50czogQXJyYXk8eyBldmVudDogc3RyaW5nOyBkYXRhOiBhbnk7IHRpbWVzdGFtcDogbnVtYmVyIH0+ID0gW107XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNlc3Npb25JZDogc3RyaW5nID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgdXNlcklkOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIGZsdXNoVGltZXI6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy51c2VySWQgPSB0aGlzLmdlbmVyYXRlVXNlcklkKCk7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplU2Vzc2lvbigpO1xyXG4gICAgICAgIHRoaXMuc2V0dXBBdXRvRmx1c2goKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlVXNlcklkKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJ3NlcnZlci11c2VyJztcclxuXHJcbiAgICAgICAgbGV0IHVzZXJJZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0aW1ldmF1bHRfdXNlcl9pZCcpO1xyXG4gICAgICAgIGlmICghdXNlcklkKSB7XHJcbiAgICAgICAgICAgIHVzZXJJZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0aW1ldmF1bHRfdXNlcl9pZCcsIHVzZXJJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1c2VySWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplU2Vzc2lvbigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy50cmFja0V2ZW50KCdzZXNzaW9uX3N0YXJ0Jywge1xyXG4gICAgICAgICAgICB1c2VyX2FnZW50OiBuYXZpZ2F0b3IudXNlckFnZW50LFxyXG4gICAgICAgICAgICBzY3JlZW5fcmVzb2x1dGlvbjogYCR7c2NyZWVuLndpZHRofXgke3NjcmVlbi5oZWlnaHR9YCxcclxuICAgICAgICAgICAgdGltZXpvbmU6IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZSxcclxuICAgICAgICAgICAgbGFuZ3VhZ2U6IG5hdmlnYXRvci5sYW5ndWFnZSxcclxuICAgICAgICAgICAgcGxhdGZvcm06IG5hdmlnYXRvci5wbGF0Zm9ybVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2V0dXBBdXRvRmx1c2goKSB7XHJcbiAgICAgICAgLy8gRmx1c2ggZXZlbnRzIGV2ZXJ5IDMwIHNlY29uZHNcclxuICAgICAgICB0aGlzLmZsdXNoVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAzMDAwMCk7XHJcblxyXG4gICAgICAgIC8vIEZsdXNoIG9uIHBhZ2UgdW5sb2FkXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0cmFja0V2ZW50KGV2ZW50OiBzdHJpbmcsIGRhdGE6IGFueSA9IHt9KSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0ge1xyXG4gICAgICAgICAgICBldmVudCxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcclxuICAgICAgICAgICAgICAgIHNlc3Npb25faWQ6IHRoaXMuc2Vzc2lvbklkLFxyXG4gICAgICAgICAgICAgICAgdXNlcl9pZDogdGhpcy51c2VySWQsXHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICBwYWdlX3VybDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICdzZXJ2ZXInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZXZlbnREYXRhKTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCB0byBHb29nbGUgQW5hbHl0aWNzIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93IGFzIGFueSkuZ3RhZykge1xyXG4gICAgICAgICAgICAod2luZG93IGFzIGFueSkuZ3RhZygnZXZlbnQnLCBldmVudCwge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRfY2F0ZWdvcnk6IGRhdGEuY2F0ZWdvcnkgfHwgJ3VzZXJfaW50ZXJhY3Rpb24nLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRfbGFiZWw6IGRhdGEubGFiZWwgfHwgJycsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YS52YWx1ZSB8fCAwLFxyXG4gICAgICAgICAgICAgICAgY3VzdG9tX3BhcmFtZXRlcnM6IGRhdGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCYXRjaCBzZW5kIHRvIGJhY2tlbmQgZXZlcnkgMTAgZXZlbnRzXHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA+PSAxMCkge1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoRXZlbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZmx1c2hFdmVudHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBldmVudHNUb1NlbmQgPSBbLi4udGhpcy5ldmVudHNdO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgYXR0ZW1wdCB0byBzZW5kIGlmIHdlJ3JlIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS9hbmFseXRpY3MvZXZlbnRzJywge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGV2ZW50c1RvU2VuZClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2VuZCBhbmFseXRpY3MgZXZlbnRzOicsIGVycm9yKTtcclxuICAgICAgICAgICAgLy8gUmUtYWRkIGZhaWxlZCBldmVudHMgYmFjayB0byBxdWV1ZSAodXAgdG8gYSBsaW1pdClcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA8IDUwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy51bnNoaWZ0KC4uLmV2ZW50c1RvU2VuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3VzdG9tZXIgRXhwZXJpZW5jZSBzcGVjaWZpYyB0cmFja2luZ1xyXG4gICAgdHJhY2tVc2VySm91cm5leShzdGVwOiBzdHJpbmcsIG1ldGFkYXRhOiBhbnkgPSB7fSkge1xyXG4gICAgICAgIHRoaXMudHJhY2tFdmVudCgndXNlcl9qb3VybmV5Jywge1xyXG4gICAgICAgICAgICBjYXRlZ29yeTogJ3V4JyxcclxuICAgICAgICAgICAgc3RlcCxcclxuICAgICAgICAgICAgLi4ubWV0YWRhdGFcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFja1BlcmZvcm1hbmNlKG1ldHJpYzogc3RyaW5nLCB2YWx1ZTogbnVtYmVyLCBjb250ZXh0OiBhbnkgPSB7fSkge1xyXG4gICAgICAgIHRoaXMudHJhY2tFdmVudCgncGVyZm9ybWFuY2VfbWV0cmljJywge1xyXG4gICAgICAgICAgICBjYXRlZ29yeTogJ3BlcmZvcm1hbmNlJyxcclxuICAgICAgICAgICAgbWV0cmljLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgLi4uY29udGV4dFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRyYWNrRXJyb3IoZXJyb3I6IEVycm9yLCBjb250ZXh0OiBhbnkgPSB7fSkge1xyXG4gICAgICAgIHRoaXMudHJhY2tFdmVudCgnZXJyb3InLCB7XHJcbiAgICAgICAgICAgIGNhdGVnb3J5OiAnZXJyb3InLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2ssXHJcbiAgICAgICAgICAgIC4uLmNvbnRleHRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDdXN0b21lciBzYXRpc2ZhY3Rpb24gdHJhY2tpbmdcclxuICAgIHRyYWNrU2F0aXNmYWN0aW9uKHJhdGluZzogbnVtYmVyLCBmZWVkYmFjazogc3RyaW5nID0gJycsIGNvbnRleHQ6IGFueSA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy50cmFja0V2ZW50KCdzYXRpc2ZhY3Rpb25fcmF0aW5nJywge1xyXG4gICAgICAgICAgICBjYXRlZ29yeTogJ2N4JyxcclxuICAgICAgICAgICAgcmF0aW5nLFxyXG4gICAgICAgICAgICBmZWVkYmFjayxcclxuICAgICAgICAgICAgLi4uY29udGV4dFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVuaGFuY2VkIHVzZXIgYmVoYXZpb3IgdHJhY2tpbmdcclxuICAgIHRyYWNrQ29udmVyc2lvbih0eXBlOiBzdHJpbmcsIHZhbHVlOiBudW1iZXIgPSAwLCBtZXRhZGF0YTogYW55ID0ge30pIHtcclxuICAgICAgICB0aGlzLnRyYWNrRXZlbnQoJ2NvbnZlcnNpb24nLCB7XHJcbiAgICAgICAgICAgIGNhdGVnb3J5OiAnY29udmVyc2lvbicsXHJcbiAgICAgICAgICAgIGNvbnZlcnNpb25fdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJhY2tFbmdhZ2VtZW50KGFjdGlvbjogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyID0gMCwgbWV0YWRhdGE6IGFueSA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy50cmFja0V2ZW50KCdlbmdhZ2VtZW50Jywge1xyXG4gICAgICAgICAgICBjYXRlZ29yeTogJ2VuZ2FnZW1lbnQnLFxyXG4gICAgICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICAuLi5tZXRhZGF0YVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFV0aWxpdHkgbWV0aG9kc1xyXG4gICAgaXNUcmFja2luZ0VuYWJsZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFuYXZpZ2F0b3IuZG9Ob3RUcmFjaztcclxuICAgIH1cclxuXHJcbiAgICBnZXRVc2VyQmVoYXZpb3JQYXR0ZXJuKCkge1xyXG4gICAgICAgIC8vIFRoaXMgd291bGQgYW5hbHl6ZSB1c2VyIGJlaGF2aW9yIHBhdHRlcm5zXHJcbiAgICAgICAgLy8gRm9yIG5vdywgcmV0dXJuIG1vY2sgZGF0YVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxpa2VseVRvVXNlUXVpejogTWF0aC5yYW5kb20oKSA+IDAuNSxcclxuICAgICAgICAgICAgbGlrZWx5VG9VcGdyYWRlOiBNYXRoLnJhbmRvbSgpID4gMC43LFxyXG4gICAgICAgICAgICBlbmdhZ2VtZW50TGV2ZWw6ICdoaWdoJyxcclxuICAgICAgICAgICAgcHJlZmVycmVkRmVhdHVyZXM6IFsnY2FsY3VsYXRvcicsICdxdWl6J11cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGdldFNlc3Npb25EYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXHJcbiAgICAgICAgICAgIHVzZXJJZDogdGhpcy51c2VySWQsXHJcbiAgICAgICAgICAgIGV2ZW50c1F1ZXVlZDogdGhpcy5ldmVudHMubGVuZ3RoXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDbGVhbnVwIG1ldGhvZFxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5mbHVzaFRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5mbHVzaFRpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mbHVzaEV2ZW50cygpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYW5hbHl0aWNzID0gbmV3IEFuYWx5dGljc0VuaGFuY2VkKCk7XHJcbiJdLCJuYW1lcyI6WyJBbmFseXRpY3NFbmhhbmNlZCIsImdlbmVyYXRlVXNlcklkIiwidXNlcklkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJzZXRJdGVtIiwiaW5pdGlhbGl6ZVNlc3Npb24iLCJ0cmFja0V2ZW50IiwidXNlcl9hZ2VudCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInNjcmVlbl9yZXNvbHV0aW9uIiwic2NyZWVuIiwid2lkdGgiLCJoZWlnaHQiLCJ0aW1lem9uZSIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsInJlc29sdmVkT3B0aW9ucyIsInRpbWVab25lIiwibGFuZ3VhZ2UiLCJwbGF0Zm9ybSIsInNldHVwQXV0b0ZsdXNoIiwiZmx1c2hUaW1lciIsInNldEludGVydmFsIiwiZXZlbnRzIiwibGVuZ3RoIiwiZmx1c2hFdmVudHMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJkYXRhIiwiZXZlbnREYXRhIiwic2Vzc2lvbl9pZCIsInNlc3Npb25JZCIsInVzZXJfaWQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwicGFnZV91cmwiLCJsb2NhdGlvbiIsImhyZWYiLCJwdXNoIiwiZ3RhZyIsImV2ZW50X2NhdGVnb3J5IiwiY2F0ZWdvcnkiLCJldmVudF9sYWJlbCIsImxhYmVsIiwidmFsdWUiLCJjdXN0b21fcGFyYW1ldGVycyIsImV2ZW50c1RvU2VuZCIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsInVuc2hpZnQiLCJ0cmFja1VzZXJKb3VybmV5Iiwic3RlcCIsIm1ldGFkYXRhIiwidHJhY2tQZXJmb3JtYW5jZSIsIm1ldHJpYyIsImNvbnRleHQiLCJ0cmFja0Vycm9yIiwibWVzc2FnZSIsInN0YWNrIiwidHJhY2tTYXRpc2ZhY3Rpb24iLCJyYXRpbmciLCJmZWVkYmFjayIsInRyYWNrQ29udmVyc2lvbiIsInR5cGUiLCJjb252ZXJzaW9uX3R5cGUiLCJ0cmFja0VuZ2FnZW1lbnQiLCJhY3Rpb24iLCJkdXJhdGlvbiIsImlzVHJhY2tpbmdFbmFibGVkIiwiZG9Ob3RUcmFjayIsImdldFVzZXJCZWhhdmlvclBhdHRlcm4iLCJsaWtlbHlUb1VzZVF1aXoiLCJNYXRoIiwicmFuZG9tIiwibGlrZWx5VG9VcGdyYWRlIiwiZW5nYWdlbWVudExldmVsIiwicHJlZmVycmVkRmVhdHVyZXMiLCJnZXRTZXNzaW9uRGF0YSIsImV2ZW50c1F1ZXVlZCIsImRlc3Ryb3kiLCJjbGVhckludGVydmFsIiwiY29uc3RydWN0b3IiLCJhbmFseXRpY3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./services/analyticsEnhanced.ts\n"));

/***/ }),

/***/ "./services/monitoringService.ts":
/*!***************************************!*\
  !*** ./services/monitoringService.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MonitoringService: function() { return /* binding */ MonitoringService; },\n/* harmony export */   monitoring: function() { return /* binding */ monitoring; }\n/* harmony export */ });\n/* harmony import */ var _analyticsEnhanced__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./analyticsEnhanced */ \"./services/analyticsEnhanced.ts\");\n\nclass MonitoringService {\n    startMonitoring() {\n        if (this.isMonitoring) return;\n        this.isMonitoring = true;\n        this.initializeMonitoring();\n    }\n    initializeMonitoring() {\n        // Performance monitoring\n        this.monitorPerformance();\n        // Error monitoring\n        this.monitorErrors();\n        // User behavior monitoring\n        this.monitorUserBehavior();\n        // Resource monitoring\n        this.monitorResources();\n    }\n    monitorPerformance() {\n        // Monitor page load times\n        if (true) {\n            window.addEventListener(\"load\", ()=>{\n                const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;\n                this.recordMetric(\"page_load_time\", loadTime);\n                if (loadTime > 3000) {\n                    this.triggerAlert(\"slow_page_load\", loadTime);\n                }\n            });\n            // Monitor API response times using performance observer\n            if (\"PerformanceObserver\" in window) {\n                const observer = new PerformanceObserver((list)=>{\n                    for (const entry of list.getEntries()){\n                        if (entry.entryType === \"navigation\") {\n                            const navEntry = entry;\n                            this.recordMetric(\"navigation_time\", navEntry.loadEventEnd - navEntry.fetchStart);\n                        }\n                    }\n                });\n                observer.observe({\n                    entryTypes: [\n                        \"navigation\"\n                    ]\n                });\n            }\n        }\n    }\n    monitorErrors() {\n        if (false) {}\n        window.addEventListener(\"error\", (event)=>{\n            this.recordMetric(\"javascript_errors\", 1);\n            _analyticsEnhanced__WEBPACK_IMPORTED_MODULE_0__.analytics.trackError(new Error(event.message), {\n                filename: event.filename,\n                lineno: event.lineno,\n                colno: event.colno\n            });\n        });\n        window.addEventListener(\"unhandledrejection\", (event)=>{\n            this.recordMetric(\"promise_rejections\", 1);\n            _analyticsEnhanced__WEBPACK_IMPORTED_MODULE_0__.analytics.trackError(new Error(String(event.reason)), {\n                type: \"unhandled_promise_rejection\"\n            });\n        });\n    }\n    monitorUserBehavior() {\n        if (false) {}\n        // Monitor user engagement\n        let engagementStart = Date.now();\n        let isEngaged = true;\n        const resetEngagement = ()=>{\n            if (isEngaged) {\n                const engagementTime = Date.now() - engagementStart;\n                this.recordMetric(\"engagement_duration\", engagementTime);\n            }\n            engagementStart = Date.now();\n            isEngaged = true;\n        };\n        // Simple throttle function\n        const throttle = (func, limit)=>{\n            let inThrottle;\n            return ()=>{\n                if (!inThrottle) {\n                    func();\n                    inThrottle = true;\n                    setTimeout(()=>inThrottle = false, limit);\n                }\n            };\n        };\n        // Track user activity\n        [\n            \"click\",\n            \"keydown\",\n            \"scroll\",\n            \"mousemove\"\n        ].forEach((event)=>{\n            document.addEventListener(event, throttle(resetEngagement, 1000));\n        });\n        // Detect user idle\n        setInterval(()=>{\n            if (Date.now() - engagementStart > 30000 && isEngaged) {\n                isEngaged = false;\n                this.recordMetric(\"user_idle_events\", 1);\n            }\n        }, 5000);\n    }\n    monitorResources() {\n        if (false) {}\n        // Monitor memory usage\n        if (\"memory\" in performance) {\n            setInterval(()=>{\n                const memory = this.monitorMemory();\n                if (memory) {\n                    this.recordMetric(\"memory_usage\", memory.used);\n                    if (memory.used > memory.limit * 0.8) {\n                        this.triggerAlert(\"high_memory_usage\", memory.used);\n                    }\n                }\n            }, 10000);\n        }\n        // Monitor network connection\n        if (\"connection\" in navigator) {\n            const connection = navigator.connection;\n            this.recordMetric(\"network_downlink\", connection.downlink || 0);\n            connection.addEventListener(\"change\", ()=>{\n                this.recordMetric(\"network_change_events\", 1);\n                _analyticsEnhanced__WEBPACK_IMPORTED_MODULE_0__.analytics.trackEvent(\"network_change\", {\n                    category: \"performance\",\n                    downlink: connection.downlink,\n                    effectiveType: connection.effectiveType\n                });\n            });\n        }\n    }\n    recordMetric(name, value) {\n        const existing = this.metrics.get(name) || [];\n        existing.push(value);\n        // Keep only last 100 measurements\n        if (existing.length > 100) {\n            existing.shift();\n        }\n        this.metrics.set(name, existing);\n    }\n    triggerAlert(alertType, value) {\n        const alert = this.alerts.get(alertType);\n        if (alert && value > alert.threshold) {\n            alert.callback();\n        }\n        // Send alert to analytics\n        _analyticsEnhanced__WEBPACK_IMPORTED_MODULE_0__.analytics.trackEvent(\"performance_alert\", {\n            category: \"monitoring\",\n            alert_type: alertType,\n            value\n        });\n    }\n    setAlert(alertType, threshold, callback) {\n        this.alerts.set(alertType, {\n            threshold,\n            callback\n        });\n    }\n    getMetrics() {\n        const result = {};\n        for (const [key, value] of this.metrics.entries()){\n            result[key] = value;\n        }\n        return result;\n    }\n    getAverageMetric(name) {\n        const values = this.metrics.get(name) || [];\n        return values.length > 0 ? values.reduce((a, b)=>a + b) / values.length : 0;\n    }\n    // Health check method\n    getHealthStatus() {\n        const memoryUsage = this.getAverageMetric(\"memory_usage\");\n        const loadTime = this.getAverageMetric(\"page_load_time\");\n        const errorRate = this.getAverageMetric(\"javascript_errors\");\n        return {\n            status: this.calculateHealthStatus(memoryUsage, loadTime, errorRate),\n            metrics: {\n                memory_usage: memoryUsage,\n                page_load_time: loadTime,\n                error_rate: errorRate\n            },\n            timestamp: Date.now()\n        };\n    }\n    calculateHealthStatus(memory, loadTime, errors) {\n        if (memory > 100 || loadTime > 5000 || errors > 5) return \"critical\";\n        if (memory > 50 || loadTime > 3000 || errors > 2) return \"warning\";\n        return \"healthy\";\n    }\n    stopMonitoring() {\n        this.isMonitoring = false;\n    // Clean up any intervals or observers here\n    }\n    // Memory monitoring utility\n    monitorMemory() {\n        if (\"memory\" in performance) {\n            const memory = performance.memory;\n            return {\n                used: Math.round(memory.usedJSHeapSize / 1048576),\n                total: Math.round(memory.totalJSHeapSize / 1048576),\n                limit: Math.round(memory.jsHeapSizeLimit / 1048576)\n            };\n        }\n        return null;\n    }\n    constructor(){\n        this.metrics = new Map();\n        this.alerts = new Map();\n        this.isMonitoring = false;\n    }\n}\nconst monitoring = new MonitoringService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZXMiOlsid2VicGFjazovL19OX0UvLi9zZXJ2aWNlcy9tb25pdG9yaW5nU2VydmljZS50cz8wMGI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFuYWx5dGljcyB9IGZyb20gJy4vYW5hbHl0aWNzRW5oYW5jZWQnO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1vbml0b3JpbmdTZXJ2aWNlIHtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0cmljcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXJbXT4oKTtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgYWxlcnRzID0gbmV3IE1hcDxzdHJpbmcsIHsgdGhyZXNob2xkOiBudW1iZXI7IGNhbGxiYWNrOiAoKSA9PiB2b2lkIH0+KCk7XHJcbiAgICBwdWJsaWMgaXNNb25pdG9yaW5nID0gZmFsc2U7XHJcblxyXG4gICAgc3RhcnRNb25pdG9yaW5nKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTW9uaXRvcmluZykgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmlzTW9uaXRvcmluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplTW9uaXRvcmluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZU1vbml0b3JpbmcoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xyXG4gICAgICAgIHRoaXMubW9uaXRvclBlcmZvcm1hbmNlKCk7XHJcblxyXG4gICAgICAgIC8vIEVycm9yIG1vbml0b3JpbmdcclxuICAgICAgICB0aGlzLm1vbml0b3JFcnJvcnMoKTtcclxuXHJcbiAgICAgICAgLy8gVXNlciBiZWhhdmlvciBtb25pdG9yaW5nXHJcbiAgICAgICAgdGhpcy5tb25pdG9yVXNlckJlaGF2aW9yKCk7XHJcblxyXG4gICAgICAgIC8vIFJlc291cmNlIG1vbml0b3JpbmdcclxuICAgICAgICB0aGlzLm1vbml0b3JSZXNvdXJjZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1vbml0b3JQZXJmb3JtYW5jZSgpOiB2b2lkIHtcclxuICAgICAgICAvLyBNb25pdG9yIHBhZ2UgbG9hZCB0aW1lc1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRUaW1lID0gcGVyZm9ybWFuY2UudGltaW5nLmxvYWRFdmVudEVuZCAtIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygncGFnZV9sb2FkX3RpbWUnLCBsb2FkVGltZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxvYWRUaW1lID4gMzAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckFsZXJ0KCdzbG93X3BhZ2VfbG9hZCcsIGxvYWRUaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBNb25pdG9yIEFQSSByZXNwb25zZSB0aW1lcyB1c2luZyBwZXJmb3JtYW5jZSBvYnNlcnZlclxyXG4gICAgICAgICAgICBpZiAoJ1BlcmZvcm1hbmNlT2JzZXJ2ZXInIGluIHdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcigobGlzdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbGlzdC5nZXRFbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmVudHJ5VHlwZSA9PT0gJ25hdmlnYXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYXZFbnRyeSA9IGVudHJ5IGFzIFBlcmZvcm1hbmNlTmF2aWdhdGlvblRpbWluZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkTWV0cmljKCduYXZpZ2F0aW9uX3RpbWUnLCBuYXZFbnRyeS5sb2FkRXZlbnRFbmQgLSBuYXZFbnRyeS5mZXRjaFN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoeyBlbnRyeVR5cGVzOiBbJ25hdmlnYXRpb24nXSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1vbml0b3JFcnJvcnMoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygnamF2YXNjcmlwdF9lcnJvcnMnLCAxKTtcclxuICAgICAgICAgICAgYW5hbHl0aWNzLnRyYWNrRXJyb3IobmV3IEVycm9yKGV2ZW50Lm1lc3NhZ2UpLCB7XHJcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogZXZlbnQuZmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICBsaW5lbm86IGV2ZW50LmxpbmVubyxcclxuICAgICAgICAgICAgICAgIGNvbG5vOiBldmVudC5jb2xub1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygncHJvbWlzZV9yZWplY3Rpb25zJywgMSk7XHJcbiAgICAgICAgICAgIGFuYWx5dGljcy50cmFja0Vycm9yKG5ldyBFcnJvcihTdHJpbmcoZXZlbnQucmVhc29uKSksIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICd1bmhhbmRsZWRfcHJvbWlzZV9yZWplY3Rpb24nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbW9uaXRvclVzZXJCZWhhdmlvcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gTW9uaXRvciB1c2VyIGVuZ2FnZW1lbnRcclxuICAgICAgICBsZXQgZW5nYWdlbWVudFN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBsZXQgaXNFbmdhZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzZXRFbmdhZ2VtZW50ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNFbmdhZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmdhZ2VtZW50VGltZSA9IERhdGUubm93KCkgLSBlbmdhZ2VtZW50U3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygnZW5nYWdlbWVudF9kdXJhdGlvbicsIGVuZ2FnZW1lbnRUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbmdhZ2VtZW50U3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBpc0VuZ2FnZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNpbXBsZSB0aHJvdHRsZSBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IHRocm90dGxlID0gKGZ1bmM6ICgpID0+IHZvaWQsIGxpbWl0OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgbGV0IGluVGhyb3R0bGU6IGJvb2xlYW47XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluVGhyb3R0bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5UaHJvdHRsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBpblRocm90dGxlID0gZmFsc2UsIGxpbWl0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBUcmFjayB1c2VyIGFjdGl2aXR5XHJcbiAgICAgICAgWydjbGljaycsICdrZXlkb3duJywgJ3Njcm9sbCcsICdtb3VzZW1vdmUnXS5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhyb3R0bGUocmVzZXRFbmdhZ2VtZW50LCAxMDAwKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIERldGVjdCB1c2VyIGlkbGVcclxuICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gZW5nYWdlbWVudFN0YXJ0ID4gMzAwMDAgJiYgaXNFbmdhZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICBpc0VuZ2FnZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkTWV0cmljKCd1c2VyX2lkbGVfZXZlbnRzJywgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCA1MDAwKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1vbml0b3JSZXNvdXJjZXMoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIE1vbml0b3IgbWVtb3J5IHVzYWdlXHJcbiAgICAgICAgaWYgKCdtZW1vcnknIGluIHBlcmZvcm1hbmNlKSB7XHJcbiAgICAgICAgICAgIHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lbW9yeSA9IHRoaXMubW9uaXRvck1lbW9yeSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lbW9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkTWV0cmljKCdtZW1vcnlfdXNhZ2UnLCBtZW1vcnkudXNlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1vcnkudXNlZCA+IG1lbW9yeS5saW1pdCAqIDAuOCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJBbGVydCgnaGlnaF9tZW1vcnlfdXNhZ2UnLCBtZW1vcnkudXNlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAxMDAwMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNb25pdG9yIG5ldHdvcmsgY29ubmVjdGlvblxyXG4gICAgICAgIGlmICgnY29ubmVjdGlvbicgaW4gbmF2aWdhdG9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSAobmF2aWdhdG9yIGFzIGFueSkuY29ubmVjdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWMoJ25ldHdvcmtfZG93bmxpbmsnLCBjb25uZWN0aW9uLmRvd25saW5rIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygnbmV0d29ya19jaGFuZ2VfZXZlbnRzJywgMSk7XHJcbiAgICAgICAgICAgICAgICBhbmFseXRpY3MudHJhY2tFdmVudCgnbmV0d29ya19jaGFuZ2UnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6ICdwZXJmb3JtYW5jZScsXHJcbiAgICAgICAgICAgICAgICAgICAgZG93bmxpbms6IGNvbm5lY3Rpb24uZG93bmxpbmssXHJcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0aXZlVHlwZTogY29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVjb3JkTWV0cmljKG5hbWU6IHN0cmluZywgdmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5tZXRyaWNzLmdldChuYW1lKSB8fCBbXTtcclxuICAgICAgICBleGlzdGluZy5wdXNoKHZhbHVlKTtcclxuXHJcbiAgICAgICAgLy8gS2VlcCBvbmx5IGxhc3QgMTAwIG1lYXN1cmVtZW50c1xyXG4gICAgICAgIGlmIChleGlzdGluZy5sZW5ndGggPiAxMDApIHtcclxuICAgICAgICAgICAgZXhpc3Rpbmcuc2hpZnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWV0cmljcy5zZXQobmFtZSwgZXhpc3RpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdHJpZ2dlckFsZXJ0KGFsZXJ0VHlwZTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgYWxlcnQgPSB0aGlzLmFsZXJ0cy5nZXQoYWxlcnRUeXBlKTtcclxuICAgICAgICBpZiAoYWxlcnQgJiYgdmFsdWUgPiBhbGVydC50aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgYWxlcnQuY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNlbmQgYWxlcnQgdG8gYW5hbHl0aWNzXHJcbiAgICAgICAgYW5hbHl0aWNzLnRyYWNrRXZlbnQoJ3BlcmZvcm1hbmNlX2FsZXJ0Jywge1xyXG4gICAgICAgICAgICBjYXRlZ29yeTogJ21vbml0b3JpbmcnLFxyXG4gICAgICAgICAgICBhbGVydF90eXBlOiBhbGVydFR5cGUsXHJcbiAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0QWxlcnQoYWxlcnRUeXBlOiBzdHJpbmcsIHRocmVzaG9sZDogbnVtYmVyLCBjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYWxlcnRzLnNldChhbGVydFR5cGUsIHsgdGhyZXNob2xkLCBjYWxsYmFjayB9KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRNZXRyaWNzKCk6IFJlY29yZDxzdHJpbmcsIG51bWJlcltdPiB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXJbXT4gPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLm1ldHJpY3MuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0QXZlcmFnZU1ldHJpYyhuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMubWV0cmljcy5nZXQobmFtZSkgfHwgW107XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPiAwID8gdmFsdWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gdmFsdWVzLmxlbmd0aCA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGVhbHRoIGNoZWNrIG1ldGhvZFxyXG4gICAgZ2V0SGVhbHRoU3RhdHVzKCkge1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gdGhpcy5nZXRBdmVyYWdlTWV0cmljKCdtZW1vcnlfdXNhZ2UnKTtcclxuICAgICAgICBjb25zdCBsb2FkVGltZSA9IHRoaXMuZ2V0QXZlcmFnZU1ldHJpYygncGFnZV9sb2FkX3RpbWUnKTtcclxuICAgICAgICBjb25zdCBlcnJvclJhdGUgPSB0aGlzLmdldEF2ZXJhZ2VNZXRyaWMoJ2phdmFzY3JpcHRfZXJyb3JzJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5jYWxjdWxhdGVIZWFsdGhTdGF0dXMobWVtb3J5VXNhZ2UsIGxvYWRUaW1lLCBlcnJvclJhdGUpLFxyXG4gICAgICAgICAgICBtZXRyaWNzOiB7XHJcbiAgICAgICAgICAgICAgICBtZW1vcnlfdXNhZ2U6IG1lbW9yeVVzYWdlLFxyXG4gICAgICAgICAgICAgICAgcGFnZV9sb2FkX3RpbWU6IGxvYWRUaW1lLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JfcmF0ZTogZXJyb3JSYXRlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVIZWFsdGhTdGF0dXMobWVtb3J5OiBudW1iZXIsIGxvYWRUaW1lOiBudW1iZXIsIGVycm9yczogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAobWVtb3J5ID4gMTAwIHx8IGxvYWRUaW1lID4gNTAwMCB8fCBlcnJvcnMgPiA1KSByZXR1cm4gJ2NyaXRpY2FsJztcclxuICAgICAgICBpZiAobWVtb3J5ID4gNTAgfHwgbG9hZFRpbWUgPiAzMDAwIHx8IGVycm9ycyA+IDIpIHJldHVybiAnd2FybmluZyc7XHJcbiAgICAgICAgcmV0dXJuICdoZWFsdGh5JztcclxuICAgIH1cclxuXHJcbiAgICBzdG9wTW9uaXRvcmluZygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmlzTW9uaXRvcmluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIENsZWFuIHVwIGFueSBpbnRlcnZhbHMgb3Igb2JzZXJ2ZXJzIGhlcmVcclxuICAgIH1cclxuXHJcbiAgICAvLyBNZW1vcnkgbW9uaXRvcmluZyB1dGlsaXR5XHJcbiAgICBwcml2YXRlIG1vbml0b3JNZW1vcnkoKSB7XHJcbiAgICAgICAgaWYgKCdtZW1vcnknIGluIHBlcmZvcm1hbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lbW9yeSA9IChwZXJmb3JtYW5jZSBhcyBhbnkpLm1lbW9yeTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVzZWQ6IE1hdGgucm91bmQobWVtb3J5LnVzZWRKU0hlYXBTaXplIC8gMTA0ODU3NiksXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogTWF0aC5yb3VuZChtZW1vcnkudG90YWxKU0hlYXBTaXplIC8gMTA0ODU3NiksXHJcbiAgICAgICAgICAgICAgICBsaW1pdDogTWF0aC5yb3VuZChtZW1vcnkuanNIZWFwU2l6ZUxpbWl0IC8gMTA0ODU3NilcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBtb25pdG9yaW5nID0gbmV3IE1vbml0b3JpbmdTZXJ2aWNlKCk7XHJcbiJdLCJuYW1lcyI6WyJhbmFseXRpY3MiLCJNb25pdG9yaW5nU2VydmljZSIsInN0YXJ0TW9uaXRvcmluZyIsImlzTW9uaXRvcmluZyIsImluaXRpYWxpemVNb25pdG9yaW5nIiwibW9uaXRvclBlcmZvcm1hbmNlIiwibW9uaXRvckVycm9ycyIsIm1vbml0b3JVc2VyQmVoYXZpb3IiLCJtb25pdG9yUmVzb3VyY2VzIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImxvYWRUaW1lIiwicGVyZm9ybWFuY2UiLCJ0aW1pbmciLCJsb2FkRXZlbnRFbmQiLCJuYXZpZ2F0aW9uU3RhcnQiLCJyZWNvcmRNZXRyaWMiLCJ0cmlnZ2VyQWxlcnQiLCJvYnNlcnZlciIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJsaXN0IiwiZW50cnkiLCJnZXRFbnRyaWVzIiwiZW50cnlUeXBlIiwibmF2RW50cnkiLCJmZXRjaFN0YXJ0Iiwib2JzZXJ2ZSIsImVudHJ5VHlwZXMiLCJldmVudCIsInRyYWNrRXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJmaWxlbmFtZSIsImxpbmVubyIsImNvbG5vIiwiU3RyaW5nIiwicmVhc29uIiwidHlwZSIsImVuZ2FnZW1lbnRTdGFydCIsIkRhdGUiLCJub3ciLCJpc0VuZ2FnZWQiLCJyZXNldEVuZ2FnZW1lbnQiLCJlbmdhZ2VtZW50VGltZSIsInRocm90dGxlIiwiZnVuYyIsImxpbWl0IiwiaW5UaHJvdHRsZSIsInNldFRpbWVvdXQiLCJmb3JFYWNoIiwiZG9jdW1lbnQiLCJzZXRJbnRlcnZhbCIsIm1lbW9yeSIsIm1vbml0b3JNZW1vcnkiLCJ1c2VkIiwibmF2aWdhdG9yIiwiY29ubmVjdGlvbiIsImRvd25saW5rIiwidHJhY2tFdmVudCIsImNhdGVnb3J5IiwiZWZmZWN0aXZlVHlwZSIsIm5hbWUiLCJ2YWx1ZSIsImV4aXN0aW5nIiwibWV0cmljcyIsImdldCIsInB1c2giLCJsZW5ndGgiLCJzaGlmdCIsInNldCIsImFsZXJ0VHlwZSIsImFsZXJ0IiwiYWxlcnRzIiwidGhyZXNob2xkIiwiY2FsbGJhY2siLCJhbGVydF90eXBlIiwic2V0QWxlcnQiLCJnZXRNZXRyaWNzIiwicmVzdWx0Iiwia2V5IiwiZW50cmllcyIsImdldEF2ZXJhZ2VNZXRyaWMiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJhIiwiYiIsImdldEhlYWx0aFN0YXR1cyIsIm1lbW9yeVVzYWdlIiwiZXJyb3JSYXRlIiwic3RhdHVzIiwiY2FsY3VsYXRlSGVhbHRoU3RhdHVzIiwibWVtb3J5X3VzYWdlIiwicGFnZV9sb2FkX3RpbWUiLCJlcnJvcl9yYXRlIiwidGltZXN0YW1wIiwiZXJyb3JzIiwic3RvcE1vbml0b3JpbmciLCJNYXRoIiwicm91bmQiLCJ1c2VkSlNIZWFwU2l6ZSIsInRvdGFsIiwidG90YWxKU0hlYXBTaXplIiwianNIZWFwU2l6ZUxpbWl0IiwiTWFwIiwibW9uaXRvcmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./services/monitoringService.ts\n"));

/***/ })

});