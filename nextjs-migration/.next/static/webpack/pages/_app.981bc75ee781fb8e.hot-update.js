"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ App; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tanstack/react-query */ \"./node_modules/@tanstack/react-query/build/modern/index.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _services_analyticsEnhanced__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../services/analyticsEnhanced */ \"./services/analyticsEnhanced.ts\");\n/* harmony import */ var _services_monitoringService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../services/monitoringService */ \"./services/monitoringService.ts\");\n/* harmony import */ var _styles_day1_app_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/day1-app.css */ \"./styles/day1-app.css\");\n/* harmony import */ var _styles_day1_app_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_day1_app_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _styles_gamification_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../styles/gamification.css */ \"./styles/gamification.css\");\n/* harmony import */ var _styles_gamification_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_styles_gamification_css__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_7__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n// Create optimized QueryClient for SSR\nfunction createQueryClient() {\n    return new _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.QueryClient({\n        defaultOptions: {\n            queries: {\n                gcTime: 5 * 60 * 1000,\n                staleTime: 30 * 1000,\n                retry: 2,\n                refetchOnWindowFocus: false,\n                refetchOnReconnect: true\n            },\n            mutations: {\n                retry: 1\n            }\n        }\n    });\n}\nfunction App(param) {\n    let { Component, pageProps } = param;\n    _s();\n    const [queryClient] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(()=>createQueryClient());\n    // Performance monitoring initialization\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        // Initialize analytics and monitoring in client\n        if (true) {\n            try {\n                // Initialize monitoring system\n                _services_monitoringService__WEBPACK_IMPORTED_MODULE_4__.monitoring.startMonitoring();\n                // Set up performance alerts\n                _services_monitoringService__WEBPACK_IMPORTED_MODULE_4__.monitoring.setAlert(\"slow_page_load\", 3000, ()=>{\n                    _services_analyticsEnhanced__WEBPACK_IMPORTED_MODULE_3__.analytics.trackEvent(\"performance_alert\", {\n                        category: \"performance\",\n                        alert_type: \"slow_page_load\"\n                    });\n                });\n                // Track app initialization\n                _services_analyticsEnhanced__WEBPACK_IMPORTED_MODULE_3__.analytics.trackEvent(\"app_initialized\", {\n                    category: \"app_lifecycle\",\n                    timestamp: Date.now(),\n                    version: \"2.0-nextjs\"\n                });\n                console.log(\"✅ TimeVault optimization systems initialized\");\n            } catch (error) {\n                console.error(\"❌ Failed to initialize optimization systems:\", error);\n            }\n        }\n        // Cleanup on unmount\n        return ()=>{\n            if (true) {\n                _services_monitoringService__WEBPACK_IMPORTED_MODULE_4__.monitoring.stopMonitoring();\n                _services_analyticsEnhanced__WEBPACK_IMPORTED_MODULE_3__.analytics.destroy();\n            }\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.QueryClientProvider, {\n        client: queryClient,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                    name: \"viewport\",\n                    content: \"width=device-width, initial-scale=1\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\kjaff\\\\OneDrive\\\\Desktop\\\\TimeVault\\\\nextjs-migration\\\\pages\\\\_app.tsx\",\n                    lineNumber: 73,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\kjaff\\\\OneDrive\\\\Desktop\\\\TimeVault\\\\nextjs-migration\\\\pages\\\\_app.tsx\",\n                lineNumber: 72,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                ...pageProps\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\kjaff\\\\OneDrive\\\\Desktop\\\\TimeVault\\\\nextjs-migration\\\\pages\\\\_app.tsx\",\n                lineNumber: 75,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\kjaff\\\\OneDrive\\\\Desktop\\\\TimeVault\\\\nextjs-migration\\\\pages\\\\_app.tsx\",\n        lineNumber: 71,\n        columnNumber: 9\n    }, this);\n}\n_s(App, \"lwV4W6/zpiIaZ1iDxgEhNj/0C4w=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUU7QUFFNUM7QUFDZTtBQUNjO0FBQ0M7QUFDM0I7QUFDSTtBQUNMO0FBRS9CLHVDQUF1QztBQUN2QyxTQUFTTztJQUNMLE9BQU8sSUFBSVAsOERBQVdBLENBQUM7UUFDbkJRLGdCQUFnQjtZQUNaQyxTQUFTO2dCQUNMQyxRQUFRLElBQUksS0FBSztnQkFDakJDLFdBQVcsS0FBSztnQkFDaEJDLE9BQU87Z0JBQ1BDLHNCQUFzQjtnQkFDdEJDLG9CQUFvQjtZQUN4QjtZQUNBQyxXQUFXO2dCQUNQSCxPQUFPO1lBQ1g7UUFDSjtJQUNKO0FBQ0o7QUFFZSxTQUFTSSxJQUFJLEtBQWtDO1FBQWxDLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFZLEdBQWxDOztJQUN4QixNQUFNLENBQUNDLFlBQVksR0FBR2YsK0NBQVFBLENBQUMsSUFBTUc7SUFFckMsd0NBQXdDO0lBQ3hDSixnREFBU0EsQ0FBQztRQUNOLGdEQUFnRDtRQUNoRCxJQUFJLElBQWtCLEVBQWE7WUFDL0IsSUFBSTtnQkFDQSwrQkFBK0I7Z0JBQy9CRyxtRUFBVUEsQ0FBQ2MsZUFBZTtnQkFFMUIsNEJBQTRCO2dCQUM1QmQsbUVBQVVBLENBQUNlLFFBQVEsQ0FBQyxrQkFBa0IsTUFBTTtvQkFDeENoQixrRUFBU0EsQ0FBQ2lCLFVBQVUsQ0FBQyxxQkFBcUI7d0JBQ3RDQyxVQUFVO3dCQUNWQyxZQUFZO29CQUNoQjtnQkFDSjtnQkFFQSwyQkFBMkI7Z0JBQzNCbkIsa0VBQVNBLENBQUNpQixVQUFVLENBQUMsbUJBQW1CO29CQUNwQ0MsVUFBVTtvQkFDVkUsV0FBV0MsS0FBS0MsR0FBRztvQkFDbkJDLFNBQVM7Z0JBQ2I7Z0JBRUFDLFFBQVFDLEdBQUcsQ0FBQztZQUNoQixFQUFFLE9BQU9DLE9BQU87Z0JBQ1pGLFFBQVFFLEtBQUssQ0FBQyxnREFBZ0RBO1lBQ2xFO1FBQ0o7UUFFQSxxQkFBcUI7UUFDckIsT0FBTztZQUNILElBQUksSUFBa0IsRUFBYTtnQkFDL0J6QixtRUFBVUEsQ0FBQzBCLGNBQWM7Z0JBQ3pCM0Isa0VBQVNBLENBQUM0QixPQUFPO1lBQ3JCO1FBQ0o7SUFDSixHQUFHLEVBQUU7SUFFTCxxQkFDSSw4REFBQ2hDLHNFQUFtQkE7UUFBQ2lDLFFBQVFmOzswQkFDekIsOERBQUNqQixrREFBSUE7MEJBQ0QsNEVBQUNpQztvQkFBS0MsTUFBSztvQkFBV0MsU0FBUTs7Ozs7Ozs7Ozs7MEJBRWxDLDhEQUFDcEI7Z0JBQVcsR0FBR0MsU0FBUzs7Ozs7Ozs7Ozs7O0FBR3BDO0dBakR3QkY7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvX2FwcC50c3g/MmZiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBRdWVyeUNsaWVudCwgUXVlcnlDbGllbnRQcm92aWRlciB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSc7XHJcbmltcG9ydCB0eXBlIHsgQXBwUHJvcHMgfSBmcm9tICduZXh0L2FwcCc7XHJcbmltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGFuYWx5dGljcyB9IGZyb20gJy4uL3NlcnZpY2VzL2FuYWx5dGljc0VuaGFuY2VkJztcclxuaW1wb3J0IHsgbW9uaXRvcmluZyB9IGZyb20gJy4uL3NlcnZpY2VzL21vbml0b3JpbmdTZXJ2aWNlJztcclxuaW1wb3J0ICcuLi9zdHlsZXMvZGF5MS1hcHAuY3NzJztcclxuaW1wb3J0ICcuLi9zdHlsZXMvZ2FtaWZpY2F0aW9uLmNzcyc7XHJcbmltcG9ydCAnLi4vc3R5bGVzL2dsb2JhbHMuY3NzJztcclxuXHJcbi8vIENyZWF0ZSBvcHRpbWl6ZWQgUXVlcnlDbGllbnQgZm9yIFNTUlxyXG5mdW5jdGlvbiBjcmVhdGVRdWVyeUNsaWVudCgpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlDbGllbnQoe1xyXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHF1ZXJpZXM6IHtcclxuICAgICAgICAgICAgICAgIGdjVGltZTogNSAqIDYwICogMTAwMCwgLy8gNSBtaW51dGVzXHJcbiAgICAgICAgICAgICAgICBzdGFsZVRpbWU6IDMwICogMTAwMCwgLy8gMzAgc2Vjb25kc1xyXG4gICAgICAgICAgICAgICAgcmV0cnk6IDIsXHJcbiAgICAgICAgICAgICAgICByZWZldGNoT25XaW5kb3dGb2N1czogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZWZldGNoT25SZWNvbm5lY3Q6IHRydWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG11dGF0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgcmV0cnk6IDEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9OiBBcHBQcm9wcykge1xyXG4gICAgY29uc3QgW3F1ZXJ5Q2xpZW50XSA9IHVzZVN0YXRlKCgpID0+IGNyZWF0ZVF1ZXJ5Q2xpZW50KCkpO1xyXG5cclxuICAgIC8vIFBlcmZvcm1hbmNlIG1vbml0b3JpbmcgaW5pdGlhbGl6YXRpb25cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbmFseXRpY3MgYW5kIG1vbml0b3JpbmcgaW4gY2xpZW50XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIG1vbml0b3Jpbmcgc3lzdGVtXHJcbiAgICAgICAgICAgICAgICBtb25pdG9yaW5nLnN0YXJ0TW9uaXRvcmluZygpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgdXAgcGVyZm9ybWFuY2UgYWxlcnRzXHJcbiAgICAgICAgICAgICAgICBtb25pdG9yaW5nLnNldEFsZXJ0KCdzbG93X3BhZ2VfbG9hZCcsIDMwMDAsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBhbmFseXRpY3MudHJhY2tFdmVudCgncGVyZm9ybWFuY2VfYWxlcnQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAncGVyZm9ybWFuY2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydF90eXBlOiAnc2xvd19wYWdlX2xvYWQnXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmFjayBhcHAgaW5pdGlhbGl6YXRpb25cclxuICAgICAgICAgICAgICAgIGFuYWx5dGljcy50cmFja0V2ZW50KCdhcHBfaW5pdGlhbGl6ZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6ICdhcHBfbGlmZWN5Y2xlJyxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJzIuMC1uZXh0anMnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFRpbWVWYXVsdCBvcHRpbWl6YXRpb24gc3lzdGVtcyBpbml0aWFsaXplZCcpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBpbml0aWFsaXplIG9wdGltaXphdGlvbiBzeXN0ZW1zOicsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xlYW51cCBvbiB1bm1vdW50XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBtb25pdG9yaW5nLnN0b3BNb25pdG9yaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBhbmFseXRpY3MuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxRdWVyeUNsaWVudFByb3ZpZGVyIGNsaWVudD17cXVlcnlDbGllbnR9PlxyXG4gICAgICAgICAgICA8SGVhZD5cclxuICAgICAgICAgICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MVwiIC8+XHJcbiAgICAgICAgICAgIDwvSGVhZD5cclxuICAgICAgICAgICAgPENvbXBvbmVudCB7Li4ucGFnZVByb3BzfSAvPlxyXG4gICAgICAgIDwvUXVlcnlDbGllbnRQcm92aWRlcj5cclxuICAgICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIlF1ZXJ5Q2xpZW50IiwiUXVlcnlDbGllbnRQcm92aWRlciIsIkhlYWQiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsImFuYWx5dGljcyIsIm1vbml0b3JpbmciLCJjcmVhdGVRdWVyeUNsaWVudCIsImRlZmF1bHRPcHRpb25zIiwicXVlcmllcyIsImdjVGltZSIsInN0YWxlVGltZSIsInJldHJ5IiwicmVmZXRjaE9uV2luZG93Rm9jdXMiLCJyZWZldGNoT25SZWNvbm5lY3QiLCJtdXRhdGlvbnMiLCJBcHAiLCJDb21wb25lbnQiLCJwYWdlUHJvcHMiLCJxdWVyeUNsaWVudCIsInN0YXJ0TW9uaXRvcmluZyIsInNldEFsZXJ0IiwidHJhY2tFdmVudCIsImNhdGVnb3J5IiwiYWxlcnRfdHlwZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJ2ZXJzaW9uIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwic3RvcE1vbml0b3JpbmciLCJkZXN0cm95IiwiY2xpZW50IiwibWV0YSIsIm5hbWUiLCJjb250ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/_app.tsx\n"));

/***/ }),

/***/ "./services/analyticsEnhanced.ts":
/*!***************************************!*\
  !*** ./services/analyticsEnhanced.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalyticsEnhanced: function() { return /* binding */ AnalyticsEnhanced; },\n/* harmony export */   analytics: function() { return /* binding */ analytics; }\n/* harmony export */ });\nclass AnalyticsEnhanced {\n    generateUserId() {\n        if (false) {}\n        let userId = localStorage.getItem(\"timevault_user_id\");\n        if (!userId) {\n            userId = crypto.randomUUID();\n            localStorage.setItem(\"timevault_user_id\", userId);\n        }\n        return userId;\n    }\n    initializeSession() {\n        if (false) {}\n        this.trackEvent(\"session_start\", {\n            user_agent: navigator.userAgent,\n            screen_resolution: \"\".concat(screen.width, \"x\").concat(screen.height),\n            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n            language: navigator.language,\n            platform: navigator.platform\n        });\n    }\n    setupAutoFlush() {\n        // Flush events every 30 seconds\n        this.flushTimer = setInterval(()=>{\n            if (this.events.length > 0) {\n                this.flushEvents();\n            }\n        }, 30000);\n        // Flush on page unload\n        if (true) {\n            window.addEventListener(\"beforeunload\", ()=>{\n                this.flushEvents();\n            });\n        }\n    }\n    trackEvent(event) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const eventData = {\n            event,\n            data: {\n                ...data,\n                session_id: this.sessionId,\n                user_id: this.userId,\n                timestamp: Date.now(),\n                page_url:  true ? window.location.href : 0\n            },\n            timestamp: Date.now()\n        };\n        this.events.push(eventData);\n        // Send to Google Analytics if available\n        if ( true && window.gtag) {\n            window.gtag(\"event\", event, {\n                event_category: data.category || \"user_interaction\",\n                event_label: data.label || \"\",\n                value: data.value || 0,\n                custom_parameters: data\n            });\n        }\n        // Batch send to backend every 10 events\n        if (this.events.length >= 10) {\n            this.flushEvents();\n        }\n    }\n    async flushEvents() {\n        if (this.events.length === 0) return;\n        const eventsToSend = [\n            ...this.events\n        ];\n        this.events.length = 0;\n        try {\n            // Only attempt to send if we're in browser environment\n            if (true) {\n                await fetch(\"/api/analytics/events\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify(eventsToSend)\n                });\n            }\n        } catch (error) {\n            console.warn(\"Failed to send analytics events:\", error);\n            // Re-add failed events back to queue (up to a limit)\n            if (this.events.length < 50) {\n                this.events.unshift(...eventsToSend);\n            }\n        }\n    }\n    // Customer Experience specific tracking\n    trackUserJourney(step) {\n        let metadata = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        this.trackEvent(\"user_journey\", {\n            category: \"ux\",\n            step,\n            ...metadata\n        });\n    }\n    trackPerformance(metric, value) {\n        let context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        this.trackEvent(\"performance_metric\", {\n            category: \"performance\",\n            metric,\n            value,\n            ...context\n        });\n    }\n    trackError(error) {\n        let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        this.trackEvent(\"error\", {\n            category: \"error\",\n            message: error.message,\n            stack: error.stack,\n            ...context\n        });\n    }\n    // Customer satisfaction tracking\n    trackSatisfaction(rating) {\n        let feedback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        this.trackEvent(\"satisfaction_rating\", {\n            category: \"cx\",\n            rating,\n            feedback,\n            ...context\n        });\n    }\n    // Enhanced user behavior tracking\n    trackConversion(type) {\n        let value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, metadata = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        this.trackEvent(\"conversion\", {\n            category: \"conversion\",\n            conversion_type: type,\n            value,\n            ...metadata\n        });\n    }\n    trackEngagement(action) {\n        let duration = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, metadata = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        this.trackEvent(\"engagement\", {\n            category: \"engagement\",\n            action,\n            duration,\n            ...metadata\n        });\n    }\n    // Utility methods\n    isTrackingEnabled() {\n        return  true && !navigator.doNotTrack;\n    }\n    getUserBehaviorPattern() {\n        // This would analyze user behavior patterns\n        // For now, return mock data\n        return {\n            likelyToUseQuiz: Math.random() > 0.5,\n            likelyToUpgrade: Math.random() > 0.7,\n            engagementLevel: \"high\",\n            preferredFeatures: [\n                \"calculator\",\n                \"quiz\"\n            ]\n        };\n    }\n    getSessionData() {\n        return {\n            sessionId: this.sessionId,\n            userId: this.userId,\n            eventsQueued: this.events.length\n        };\n    }\n    // Cleanup method\n    destroy() {\n        if (this.flushTimer) {\n            clearInterval(this.flushTimer);\n        }\n        this.flushEvents();\n    }\n    constructor(){\n        this.events = [];\n        this.sessionId = crypto.randomUUID();\n        this.flushTimer = null;\n        this.userId = this.generateUserId();\n        this.initializeSession();\n        this.setupAutoFlush();\n    }\n}\nconst analytics = new AnalyticsEnhanced();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTFDQyxXQUFBQSxpRUFBbUIsR0FBR2YsV0FBQUEsaUVBQWdCLENBQUM7UUFDckUsSUFBSSxDQUFDeEQsVUFBVSxDQUFDLGNBQWM7WUFDNUJzQyxVQUFVO1lBQ1ZnQztZQUNBQztZQUNBLEdBQUdmLFFBQVE7UUFDYjtJQUNGO0lBRUEsa0JBQWtCO0lBQ2xCZ0Isb0JBQTZCO1FBQzNCLE9BQU8sS0FBa0IsSUFBZSxDQUFDdEUsVUFBVXVFLFVBQVU7SUFDL0Q7SUFFQUMseUJBQXlCO1FBQ3ZCLDRDQUE0QztRQUM1Qyw0QkFBNEI7UUFDNUIsT0FBTztZQUNMQyxpQkFBaUJDLEtBQUtDLE1BQU0sS0FBSztZQUNqQ0MsaUJBQWlCRixLQUFLQyxNQUFNLEtBQUs7WUFDakNFLGlCQUFpQjtZQUNqQkMsbUJBQW1CO2dCQUFDO2dCQUFjO2FBQU87UUFDM0M7SUFDRjtJQUVBQyxpQkFBaUI7UUFDZixPQUFPO1lBQ0x0RCxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QmxDLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CeUYsY0FBYyxJQUFJLENBQUNoRSxNQUFNLENBQUNDLE1BQU07UUFDbEM7SUFDRjtJQUVBLGlCQUFpQjtJQUNqQmdFLFVBQVU7UUFDUixJQUFJLElBQUksQ0FBQ25FLFVBQVUsRUFBRTtZQUNuQm9FLGNBQWMsSUFBSSxDQUFDcEUsVUFBVTtRQUMvQjtRQUNBLElBQUksQ0FBQ0ksV0FBVztJQUNsQjtJQTFMQWlFLGFBQWM7YUFMR25FLFNBQWlFLEVBQUU7YUFDbkVTLFlBQW9CL0IsT0FBT0MsVUFBVTthQUU5Q21CLGFBQW9DO1FBRzFDLElBQUksQ0FBQ3ZCLE1BQU0sR0FBRyxJQUFJLENBQUNELGNBQWM7UUFDakMsSUFBSSxDQUFDTyxpQkFBaUI7UUFDdEIsSUFBSSxDQUFDZ0IsY0FBYztJQUNyQjtBQXVMRjtBQUVPLE1BQU11RSxZQUFZLElBQUkvRixvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc2VydmljZXMvYW5hbHl0aWNzRW5oYW5jZWQudHM/YmRlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgQW5hbHl0aWNzRW5oYW5jZWQge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRzOiBBcnJheTx7IGV2ZW50OiBzdHJpbmc7IGRhdGE6IGFueTsgdGltZXN0YW1wOiBudW1iZXIgfT4gPSBbXTtcclxuICBwcml2YXRlIHJlYWRvbmx5IHNlc3Npb25JZDogc3RyaW5nID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcclxuICBwcml2YXRlIHJlYWRvbmx5IHVzZXJJZDogc3RyaW5nO1xyXG4gIHByaXZhdGUgZmx1c2hUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnVzZXJJZCA9IHRoaXMuZ2VuZXJhdGVVc2VySWQoKTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZVNlc3Npb24oKTtcclxuICAgIHRoaXMuc2V0dXBBdXRvRmx1c2goKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2VuZXJhdGVVc2VySWQoKTogc3RyaW5nIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuICdzZXJ2ZXItdXNlcic7XHJcbiAgICBcclxuICAgIGxldCB1c2VySWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndGltZXZhdWx0X3VzZXJfaWQnKTtcclxuICAgIGlmICghdXNlcklkKSB7XHJcbiAgICAgIHVzZXJJZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0aW1ldmF1bHRfdXNlcl9pZCcsIHVzZXJJZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXNlcklkO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpbml0aWFsaXplU2Vzc2lvbigpIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gICAgXHJcbiAgICB0aGlzLnRyYWNrRXZlbnQoJ3Nlc3Npb25fc3RhcnQnLCB7XHJcbiAgICAgIHVzZXJfYWdlbnQ6IG5hdmlnYXRvci51c2VyQWdlbnQsXHJcbiAgICAgIHNjcmVlbl9yZXNvbHV0aW9uOiBgJHtzY3JlZW4ud2lkdGh9eCR7c2NyZWVuLmhlaWdodH1gLFxyXG4gICAgICB0aW1lem9uZTogSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lLFxyXG4gICAgICBsYW5ndWFnZTogbmF2aWdhdG9yLmxhbmd1YWdlLFxyXG4gICAgICBwbGF0Zm9ybTogbmF2aWdhdG9yLnBsYXRmb3JtXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2V0dXBBdXRvRmx1c2goKSB7XHJcbiAgICAvLyBGbHVzaCBldmVudHMgZXZlcnkgMzAgc2Vjb25kc1xyXG4gICAgdGhpcy5mbHVzaFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5ldmVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuZmx1c2hFdmVudHMoKTtcclxuICAgICAgfVxyXG4gICAgfSwgMzAwMDApO1xyXG5cclxuICAgIC8vIEZsdXNoIG9uIHBhZ2UgdW5sb2FkXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsICgpID0+IHtcclxuICAgICAgICB0aGlzLmZsdXNoRXZlbnRzKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdHJhY2tFdmVudChldmVudDogc3RyaW5nLCBkYXRhOiBhbnkgPSB7fSkge1xyXG4gICAgY29uc3QgZXZlbnREYXRhID0ge1xyXG4gICAgICBldmVudCxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIC4uLmRhdGEsXHJcbiAgICAgICAgc2Vzc2lvbl9pZDogdGhpcy5zZXNzaW9uSWQsXHJcbiAgICAgICAgdXNlcl9pZDogdGhpcy51c2VySWQsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgIHBhZ2VfdXJsOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5ocmVmIDogJ3NlcnZlcidcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZXZlbnRzLnB1c2goZXZlbnREYXRhKTtcclxuXHJcbiAgICAvLyBTZW5kIHRvIEdvb2dsZSBBbmFseXRpY3MgaWYgYXZhaWxhYmxlXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdyBhcyBhbnkpLmd0YWcpIHtcclxuICAgICAgKHdpbmRvdyBhcyBhbnkpLmd0YWcoJ2V2ZW50JywgZXZlbnQsIHtcclxuICAgICAgICBldmVudF9jYXRlZ29yeTogZGF0YS5jYXRlZ29yeSB8fCAndXNlcl9pbnRlcmFjdGlvbicsXHJcbiAgICAgICAgZXZlbnRfbGFiZWw6IGRhdGEubGFiZWwgfHwgJycsXHJcbiAgICAgICAgdmFsdWU6IGRhdGEudmFsdWUgfHwgMCxcclxuICAgICAgICBjdXN0b21fcGFyYW1ldGVyczogZGF0YVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCYXRjaCBzZW5kIHRvIGJhY2tlbmQgZXZlcnkgMTAgZXZlbnRzXHJcbiAgICBpZiAodGhpcy5ldmVudHMubGVuZ3RoID49IDEwKSB7XHJcbiAgICAgIHRoaXMuZmx1c2hFdmVudHMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZmx1c2hFdmVudHMoKSB7XHJcbiAgICBpZiAodGhpcy5ldmVudHMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgZXZlbnRzVG9TZW5kID0gWy4uLnRoaXMuZXZlbnRzXTtcclxuICAgIHRoaXMuZXZlbnRzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gT25seSBhdHRlbXB0IHRvIHNlbmQgaWYgd2UncmUgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS9hbmFseXRpY3MvZXZlbnRzJywge1xyXG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGV2ZW50c1RvU2VuZClcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2VuZCBhbmFseXRpY3MgZXZlbnRzOicsIGVycm9yKTtcclxuICAgICAgLy8gUmUtYWRkIGZhaWxlZCBldmVudHMgYmFjayB0byBxdWV1ZSAodXAgdG8gYSBsaW1pdClcclxuICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA8IDUwKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudHMudW5zaGlmdCguLi5ldmVudHNUb1NlbmQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDdXN0b21lciBFeHBlcmllbmNlIHNwZWNpZmljIHRyYWNraW5nXHJcbiAgdHJhY2tVc2VySm91cm5leShzdGVwOiBzdHJpbmcsIG1ldGFkYXRhOiBhbnkgPSB7fSkge1xyXG4gICAgdGhpcy50cmFja0V2ZW50KCd1c2VyX2pvdXJuZXknLCB7XHJcbiAgICAgIGNhdGVnb3J5OiAndXgnLFxyXG4gICAgICBzdGVwLFxyXG4gICAgICAuLi5tZXRhZGF0YVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB0cmFja1BlcmZvcm1hbmNlKG1ldHJpYzogc3RyaW5nLCB2YWx1ZTogbnVtYmVyLCBjb250ZXh0OiBhbnkgPSB7fSkge1xyXG4gICAgdGhpcy50cmFja0V2ZW50KCdwZXJmb3JtYW5jZV9tZXRyaWMnLCB7XHJcbiAgICAgIGNhdGVnb3J5OiAncGVyZm9ybWFuY2UnLFxyXG4gICAgICBtZXRyaWMsXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICAuLi5jb250ZXh0XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHRyYWNrRXJyb3IoZXJyb3I6IEVycm9yLCBjb250ZXh0OiBhbnkgPSB7fSkge1xyXG4gICAgdGhpcy50cmFja0V2ZW50KCdlcnJvcicsIHtcclxuICAgICAgY2F0ZWdvcnk6ICdlcnJvcicsXHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgIHN0YWNrOiBlcnJvci5zdGFjayxcclxuICAgICAgLi4uY29udGV4dFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBDdXN0b21lciBzYXRpc2ZhY3Rpb24gdHJhY2tpbmdcclxuICB0cmFja1NhdGlzZmFjdGlvbihyYXRpbmc6IG51bWJlciwgZmVlZGJhY2s6IHN0cmluZyA9ICcnLCBjb250ZXh0OiBhbnkgPSB7fSkge1xyXG4gICAgdGhpcy50cmFja0V2ZW50KCdzYXRpc2ZhY3Rpb25fcmF0aW5nJywge1xyXG4gICAgICBjYXRlZ29yeTogJ2N4JyxcclxuICAgICAgcmF0aW5nLFxyXG4gICAgICBmZWVkYmFjayxcclxuICAgICAgLi4uY29udGV4dFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCB1c2VyIGJlaGF2aW9yIHRyYWNraW5nXHJcbiAgdHJhY2tDb252ZXJzaW9uKHR5cGU6IHN0cmluZywgdmFsdWU6IG51bWJlciA9IDAsIG1ldGFkYXRhOiBhbnkgPSB7fSkge1xyXG4gICAgdGhpcy50cmFja0V2ZW50KCdjb252ZXJzaW9uJywge1xyXG4gICAgICBjYXRlZ29yeTogJ2NvbnZlcnNpb24nLFxyXG4gICAgICBjb252ZXJzaW9uX3R5cGU6IHR5cGUsXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICAuLi5tZXRhZGF0YVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB0cmFja0VuZ2FnZW1lbnQoYWN0aW9uOiBzdHJpbmcsIGR1cmF0aW9uOiBudW1iZXIgPSAwLCBtZXRhZGF0YTogYW55ID0ge30pIHtcclxuICAgIHRoaXMudHJhY2tFdmVudCgnZW5nYWdlbWVudCcsIHtcclxuICAgICAgY2F0ZWdvcnk6ICdlbmdhZ2VtZW50JyxcclxuICAgICAgYWN0aW9uLFxyXG4gICAgICBkdXJhdGlvbixcclxuICAgICAgLi4ubWV0YWRhdGFcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gVXRpbGl0eSBtZXRob2RzXHJcbiAgaXNUcmFja2luZ0VuYWJsZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIW5hdmlnYXRvci5kb05vdFRyYWNrO1xyXG4gIH1cclxuXHJcbiAgZ2V0VXNlckJlaGF2aW9yUGF0dGVybigpIHtcclxuICAgIC8vIFRoaXMgd291bGQgYW5hbHl6ZSB1c2VyIGJlaGF2aW9yIHBhdHRlcm5zXHJcbiAgICAvLyBGb3Igbm93LCByZXR1cm4gbW9jayBkYXRhXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsaWtlbHlUb1VzZVF1aXo6IE1hdGgucmFuZG9tKCkgPiAwLjUsXHJcbiAgICAgIGxpa2VseVRvVXBncmFkZTogTWF0aC5yYW5kb20oKSA+IDAuNyxcclxuICAgICAgZW5nYWdlbWVudExldmVsOiAnaGlnaCcsXHJcbiAgICAgIHByZWZlcnJlZEZlYXR1cmVzOiBbJ2NhbGN1bGF0b3InLCAncXVpeiddXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0U2Vzc2lvbkRhdGEoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxyXG4gICAgICB1c2VySWQ6IHRoaXMudXNlcklkLFxyXG4gICAgICBldmVudHNRdWV1ZWQ6IHRoaXMuZXZlbnRzLmxlbmd0aFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIENsZWFudXAgbWV0aG9kXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLmZsdXNoVGltZXIpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmZsdXNoVGltZXIpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5mbHVzaEV2ZW50cygpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGFuYWx5dGljcyA9IG5ldyBBbmFseXRpY3NFbmhhbmNlZCgpO1xyXG4iXSwibmFtZXMiOlsiQW5hbHl0aWNzRW5oYW5jZWQiLCJnZW5lcmF0ZVVzZXJJZCIsInVzZXJJZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwic2V0SXRlbSIsImluaXRpYWxpemVTZXNzaW9uIiwidHJhY2tFdmVudCIsInVzZXJfYWdlbnQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJzY3JlZW5fcmVzb2x1dGlvbiIsInNjcmVlbiIsIndpZHRoIiwiaGVpZ2h0IiwidGltZXpvbmUiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJyZXNvbHZlZE9wdGlvbnMiLCJ0aW1lWm9uZSIsImxhbmd1YWdlIiwicGxhdGZvcm0iLCJzZXR1cEF1dG9GbHVzaCIsImZsdXNoVGltZXIiLCJzZXRJbnRlcnZhbCIsImV2ZW50cyIsImxlbmd0aCIsImZsdXNoRXZlbnRzIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiZGF0YSIsImV2ZW50RGF0YSIsInNlc3Npb25faWQiLCJzZXNzaW9uSWQiLCJ1c2VyX2lkIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInBhZ2VfdXJsIiwibG9jYXRpb24iLCJocmVmIiwicHVzaCIsImd0YWciLCJldmVudF9jYXRlZ29yeSIsImNhdGVnb3J5IiwiZXZlbnRfbGFiZWwiLCJsYWJlbCIsInZhbHVlIiwiY3VzdG9tX3BhcmFtZXRlcnMiLCJldmVudHNUb1NlbmQiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJ1bnNoaWZ0IiwidHJhY2tVc2VySm91cm5leSIsInN0ZXAiLCJtZXRhZGF0YSIsInRyYWNrUGVyZm9ybWFuY2UiLCJtZXRyaWMiLCJjb250ZXh0IiwidHJhY2tFcnJvciIsIm1lc3NhZ2UiLCJzdGFjayIsInRyYWNrU2F0aXNmYWN0aW9uIiwicmF0aW5nIiwiZmVlZGJhY2siLCJ0cmFja0NvbnZlcnNpb24iLCJ0eXBlIiwiY29udmVyc2lvbl90eXBlIiwidHJhY2tFbmdhZ2VtZW50IiwiYWN0aW9uIiwiZHVyYXRpb24iLCJpc1RyYWNraW5nRW5hYmxlZCIsImRvTm90VHJhY2siLCJnZXRVc2VyQmVoYXZpb3JQYXR0ZXJuIiwibGlrZWx5VG9Vc2VRdWl6IiwiTWF0aCIsInJhbmRvbSIsImxpa2VseVRvVXBncmFkZSIsImVuZ2FnZW1lbnRMZXZlbCIsInByZWZlcnJlZEZlYXR1cmVzIiwiZ2V0U2Vzc2lvbkRhdGEiLCJldmVudHNRdWV1ZWQiLCJkZXN0cm95IiwiY2xlYXJJbnRlcnZhbCIsImNvbnN0cnVjdG9yIiwiYW5hbHl0aWNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./services/analyticsEnhanced.ts\n"));

/***/ }),

/***/ "./services/monitoringService.ts":
/*!***************************************!*\
  !*** ./services/monitoringService.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MonitoringService: function() { return /* binding */ MonitoringService; },\n/* harmony export */   monitoring: function() { return /* binding */ monitoring; }\n/* harmony export */ });\n/* harmony import */ var _analyticsEnhanced__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./analyticsEnhanced */ \"./services/analyticsEnhanced.ts\");\n\nclass MonitoringService {\n    startMonitoring() {\n        if (this.isMonitoring) return;\n        this.isMonitoring = true;\n        this.initializeMonitoring();\n    }\n    initializeMonitoring() {\n        // Performance monitoring\n        this.monitorPerformance();\n        // Error monitoring\n        this.monitorErrors();\n        // User behavior monitoring\n        this.monitorUserBehavior();\n        // Resource monitoring\n        this.monitorResources();\n    }\n    monitorPerformance() {\n        // Monitor page load times\n        if (true) {\n            window.addEventListener(\"load\", ()=>{\n                const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;\n                this.recordMetric(\"page_load_time\", loadTime);\n                if (loadTime > 3000) {\n                    this.triggerAlert(\"slow_page_load\", loadTime);\n                }\n            });\n            // Monitor API response times using performance observer\n            if (\"PerformanceObserver\" in window) {\n                const observer = new PerformanceObserver((list)=>{\n                    for (const entry of list.getEntries()){\n                        if (entry.entryType === \"navigation\") {\n                            const navEntry = entry;\n                            this.recordMetric(\"navigation_time\", navEntry.loadEventEnd - navEntry.fetchStart);\n                        }\n                    }\n                });\n                observer.observe({\n                    entryTypes: [\n                        \"navigation\"\n                    ]\n                });\n            }\n        }\n    }\n    monitorErrors() {\n        if (false) {}\n        window.addEventListener(\"error\", (event)=>{\n            this.recordMetric(\"javascript_errors\", 1);\n            _analyticsEnhanced__WEBPACK_IMPORTED_MODULE_0__.analytics.trackError(new Error(event.message), {\n                filename: event.filename,\n                lineno: event.lineno,\n                colno: event.colno\n            });\n        });\n        window.addEventListener(\"unhandledrejection\", (event)=>{\n            this.recordMetric(\"promise_rejections\", 1);\n            _analyticsEnhanced__WEBPACK_IMPORTED_MODULE_0__.analytics.trackError(new Error(String(event.reason)), {\n                type: \"unhandled_promise_rejection\"\n            });\n        });\n    }\n    monitorUserBehavior() {\n        if (false) {}\n        // Monitor user engagement\n        let engagementStart = Date.now();\n        let isEngaged = true;\n        const resetEngagement = ()=>{\n            if (isEngaged) {\n                const engagementTime = Date.now() - engagementStart;\n                this.recordMetric(\"engagement_duration\", engagementTime);\n            }\n            engagementStart = Date.now();\n            isEngaged = true;\n        };\n        // Simple throttle function\n        const throttle = (func, limit)=>{\n            let inThrottle;\n            return ()=>{\n                if (!inThrottle) {\n                    func();\n                    inThrottle = true;\n                    setTimeout(()=>inThrottle = false, limit);\n                }\n            };\n        };\n        // Track user activity\n        [\n            \"click\",\n            \"keydown\",\n            \"scroll\",\n            \"mousemove\"\n        ].forEach((event)=>{\n            document.addEventListener(event, throttle(resetEngagement, 1000));\n        });\n        // Detect user idle\n        setInterval(()=>{\n            if (Date.now() - engagementStart > 30000 && isEngaged) {\n                isEngaged = false;\n                this.recordMetric(\"user_idle_events\", 1);\n            }\n        }, 5000);\n    }\n    monitorResources() {\n        if (false) {}\n        // Monitor memory usage\n        if (\"memory\" in performance) {\n            setInterval(()=>{\n                const memory = this.monitorMemory();\n                if (memory) {\n                    this.recordMetric(\"memory_usage\", memory.used);\n                    if (memory.used > memory.limit * 0.8) {\n                        this.triggerAlert(\"high_memory_usage\", memory.used);\n                    }\n                }\n            }, 10000);\n        }\n        // Monitor network connection\n        if (\"connection\" in navigator) {\n            const connection = navigator.connection;\n            this.recordMetric(\"network_downlink\", connection.downlink || 0);\n            connection.addEventListener(\"change\", ()=>{\n                this.recordMetric(\"network_change_events\", 1);\n                _analyticsEnhanced__WEBPACK_IMPORTED_MODULE_0__.analytics.trackEvent(\"network_change\", {\n                    category: \"performance\",\n                    downlink: connection.downlink,\n                    effectiveType: connection.effectiveType\n                });\n            });\n        }\n    }\n    recordMetric(name, value) {\n        const existing = this.metrics.get(name) || [];\n        existing.push(value);\n        // Keep only last 100 measurements\n        if (existing.length > 100) {\n            existing.shift();\n        }\n        this.metrics.set(name, existing);\n    }\n    triggerAlert(alertType, value) {\n        const alert = this.alerts.get(alertType);\n        if (alert && value > alert.threshold) {\n            alert.callback();\n        }\n        // Send alert to analytics\n        _analyticsEnhanced__WEBPACK_IMPORTED_MODULE_0__.analytics.trackEvent(\"performance_alert\", {\n            category: \"monitoring\",\n            alert_type: alertType,\n            value\n        });\n    }\n    setAlert(alertType, threshold, callback) {\n        this.alerts.set(alertType, {\n            threshold,\n            callback\n        });\n    }\n    getMetrics() {\n        const result = {};\n        for (const [key, value] of this.metrics.entries()){\n            result[key] = value;\n        }\n        return result;\n    }\n    getAverageMetric(name) {\n        const values = this.metrics.get(name) || [];\n        return values.length > 0 ? values.reduce((a, b)=>a + b) / values.length : 0;\n    }\n    // Health check method\n    getHealthStatus() {\n        const memoryUsage = this.getAverageMetric(\"memory_usage\");\n        const loadTime = this.getAverageMetric(\"page_load_time\");\n        const errorRate = this.getAverageMetric(\"javascript_errors\");\n        return {\n            status: this.calculateHealthStatus(memoryUsage, loadTime, errorRate),\n            metrics: {\n                memory_usage: memoryUsage,\n                page_load_time: loadTime,\n                error_rate: errorRate\n            },\n            timestamp: Date.now()\n        };\n    }\n    calculateHealthStatus(memory, loadTime, errors) {\n        if (memory > 100 || loadTime > 5000 || errors > 5) return \"critical\";\n        if (memory > 50 || loadTime > 3000 || errors > 2) return \"warning\";\n        return \"healthy\";\n    }\n    stopMonitoring() {\n        this.isMonitoring = false;\n    // Clean up any intervals or observers here\n    }\n    // Memory monitoring utility\n    monitorMemory() {\n        if (\"memory\" in performance) {\n            const memory = performance.memory;\n            return {\n                used: Math.round(memory.usedJSHeapSize / 1048576),\n                total: Math.round(memory.totalJSHeapSize / 1048576),\n                limit: Math.round(memory.jsHeapSizeLimit / 1048576)\n            };\n        }\n        return null;\n    }\n    constructor(){\n        this.metrics = new Map();\n        this.alerts = new Map();\n        this.isMonitoring = false;\n    }\n}\nconst monitoring = new MonitoringService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NlcnZpY2VzL21vbml0b3JpbmdTZXJ2aWNlLnRzPzAwYjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGVyZm9ybWFuY2VPcHRpbWl6ZXIgfSBmcm9tICcuLi91dGlscy9wZXJmb3JtYW5jZU9wdGltaXplcic7XHJcbmltcG9ydCB7IGFuYWx5dGljcyB9IGZyb20gJy4vYW5hbHl0aWNzRW5oYW5jZWQnO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1vbml0b3JpbmdTZXJ2aWNlIHtcclxuICBwcml2YXRlIHJlYWRvbmx5IG1ldHJpY3MgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyW10+KCk7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBhbGVydHMgPSBuZXcgTWFwPHN0cmluZywgeyB0aHJlc2hvbGQ6IG51bWJlcjsgY2FsbGJhY2s6ICgpID0+IHZvaWQgfT4oKTtcclxuICBwdWJsaWMgaXNNb25pdG9yaW5nID0gZmFsc2U7XHJcblxyXG4gIHN0YXJ0TW9uaXRvcmluZygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmlzTW9uaXRvcmluZykgcmV0dXJuO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzTW9uaXRvcmluZyA9IHRydWU7XHJcbiAgICB0aGlzLmluaXRpYWxpemVNb25pdG9yaW5nKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGluaXRpYWxpemVNb25pdG9yaW5nKCk6IHZvaWQge1xyXG4gICAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xyXG4gICAgdGhpcy5tb25pdG9yUGVyZm9ybWFuY2UoKTtcclxuICAgIFxyXG4gICAgLy8gRXJyb3IgbW9uaXRvcmluZ1xyXG4gICAgdGhpcy5tb25pdG9yRXJyb3JzKCk7XHJcbiAgICBcclxuICAgIC8vIFVzZXIgYmVoYXZpb3IgbW9uaXRvcmluZ1xyXG4gICAgdGhpcy5tb25pdG9yVXNlckJlaGF2aW9yKCk7XHJcbiAgICBcclxuICAgIC8vIFJlc291cmNlIG1vbml0b3JpbmdcclxuICAgIHRoaXMubW9uaXRvclJlc291cmNlcygpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBtb25pdG9yUGVyZm9ybWFuY2UoKTogdm9pZCB7XHJcbiAgICAvLyBNb25pdG9yIHBhZ2UgbG9hZCB0aW1lc1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGxvYWRUaW1lID0gcGVyZm9ybWFuY2UudGltaW5nLmxvYWRFdmVudEVuZCAtIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWMoJ3BhZ2VfbG9hZF90aW1lJywgbG9hZFRpbWUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChsb2FkVGltZSA+IDMwMDApIHtcclxuICAgICAgICAgIHRoaXMudHJpZ2dlckFsZXJ0KCdzbG93X3BhZ2VfbG9hZCcsIGxvYWRUaW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gTW9uaXRvciBBUEkgcmVzcG9uc2UgdGltZXMgdXNpbmcgcGVyZm9ybWFuY2Ugb2JzZXJ2ZXJcclxuICAgICAgaWYgKCdQZXJmb3JtYW5jZU9ic2VydmVyJyBpbiB3aW5kb3cpIHtcclxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChsaXN0KSA9PiB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGxpc3QuZ2V0RW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5lbnRyeVR5cGUgPT09ICduYXZpZ2F0aW9uJykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5hdkVudHJ5ID0gZW50cnkgYXMgUGVyZm9ybWFuY2VOYXZpZ2F0aW9uVGltaW5nO1xyXG4gICAgICAgICAgICAgIHRoaXMucmVjb3JkTWV0cmljKCduYXZpZ2F0aW9uX3RpbWUnLCBuYXZFbnRyeS5sb2FkRXZlbnRFbmQgLSBuYXZFbnRyeS5mZXRjaFN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoeyBlbnRyeVR5cGVzOiBbJ25hdmlnYXRpb24nXSB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBtb25pdG9yRXJyb3JzKCk6IHZvaWQge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICBcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4ge1xyXG4gICAgICB0aGlzLnJlY29yZE1ldHJpYygnamF2YXNjcmlwdF9lcnJvcnMnLCAxKTtcclxuICAgICAgYW5hbHl0aWNzLnRyYWNrRXJyb3IobmV3IEVycm9yKGV2ZW50Lm1lc3NhZ2UpLCB7XHJcbiAgICAgICAgZmlsZW5hbWU6IGV2ZW50LmZpbGVuYW1lLFxyXG4gICAgICAgIGxpbmVubzogZXZlbnQubGluZW5vLFxyXG4gICAgICAgIGNvbG5vOiBldmVudC5jb2xub1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCAoZXZlbnQpID0+IHtcclxuICAgICAgdGhpcy5yZWNvcmRNZXRyaWMoJ3Byb21pc2VfcmVqZWN0aW9ucycsIDEpO1xyXG4gICAgICBhbmFseXRpY3MudHJhY2tFcnJvcihuZXcgRXJyb3IoU3RyaW5nKGV2ZW50LnJlYXNvbikpLCB7XHJcbiAgICAgICAgdHlwZTogJ3VuaGFuZGxlZF9wcm9taXNlX3JlamVjdGlvbidcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbW9uaXRvclVzZXJCZWhhdmlvcigpOiB2b2lkIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gICAgXHJcbiAgICAvLyBNb25pdG9yIHVzZXIgZW5nYWdlbWVudFxyXG4gICAgbGV0IGVuZ2FnZW1lbnRTdGFydCA9IERhdGUubm93KCk7XHJcbiAgICBsZXQgaXNFbmdhZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICBjb25zdCByZXNldEVuZ2FnZW1lbnQgPSAoKSA9PiB7XHJcbiAgICAgIGlmIChpc0VuZ2FnZWQpIHtcclxuICAgICAgICBjb25zdCBlbmdhZ2VtZW50VGltZSA9IERhdGUubm93KCkgLSBlbmdhZ2VtZW50U3RhcnQ7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWMoJ2VuZ2FnZW1lbnRfZHVyYXRpb24nLCBlbmdhZ2VtZW50VGltZSk7XHJcbiAgICAgIH1cclxuICAgICAgZW5nYWdlbWVudFN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgaXNFbmdhZ2VkID0gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gU2ltcGxlIHRocm90dGxlIGZ1bmN0aW9uXHJcbiAgICBjb25zdCB0aHJvdHRsZSA9IChmdW5jOiAoKSA9PiB2b2lkLCBsaW1pdDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGxldCBpblRocm90dGxlOiBib29sZWFuO1xyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGlmICghaW5UaHJvdHRsZSkge1xyXG4gICAgICAgICAgZnVuYygpO1xyXG4gICAgICAgICAgaW5UaHJvdHRsZSA9IHRydWU7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGluVGhyb3R0bGUgPSBmYWxzZSwgbGltaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVHJhY2sgdXNlciBhY3Rpdml0eVxyXG4gICAgWydjbGljaycsICdrZXlkb3duJywgJ3Njcm9sbCcsICdtb3VzZW1vdmUnXS5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhyb3R0bGUocmVzZXRFbmdhZ2VtZW50LCAxMDAwKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEZXRlY3QgdXNlciBpZGxlXHJcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGlmIChEYXRlLm5vdygpIC0gZW5nYWdlbWVudFN0YXJ0ID4gMzAwMDAgJiYgaXNFbmdhZ2VkKSB7XHJcbiAgICAgICAgaXNFbmdhZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWMoJ3VzZXJfaWRsZV9ldmVudHMnLCAxKTtcclxuICAgICAgfVxyXG4gICAgfSwgNTAwMCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG1vbml0b3JSZXNvdXJjZXMoKTogdm9pZCB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcclxuICAgIFxyXG4gICAgLy8gTW9uaXRvciBtZW1vcnkgdXNhZ2VcclxuICAgIGlmICgnbWVtb3J5JyBpbiBwZXJmb3JtYW5jZSkge1xyXG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbWVtb3J5ID0gdGhpcy5tb25pdG9yTWVtb3J5KCk7XHJcbiAgICAgICAgaWYgKG1lbW9yeSkge1xyXG4gICAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWMoJ21lbW9yeV91c2FnZScsIG1lbW9yeS51c2VkKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKG1lbW9yeS51c2VkID4gbWVtb3J5LmxpbWl0ICogMC44KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckFsZXJ0KCdoaWdoX21lbW9yeV91c2FnZScsIG1lbW9yeS51c2VkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sIDEwMDAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNb25pdG9yIG5ldHdvcmsgY29ubmVjdGlvblxyXG4gICAgaWYgKCdjb25uZWN0aW9uJyBpbiBuYXZpZ2F0b3IpIHtcclxuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IChuYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uO1xyXG4gICAgICB0aGlzLnJlY29yZE1ldHJpYygnbmV0d29ya19kb3dubGluaycsIGNvbm5lY3Rpb24uZG93bmxpbmsgfHwgMCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICB0aGlzLnJlY29yZE1ldHJpYygnbmV0d29ya19jaGFuZ2VfZXZlbnRzJywgMSk7XHJcbiAgICAgICAgYW5hbHl0aWNzLnRyYWNrRXZlbnQoJ25ldHdvcmtfY2hhbmdlJywge1xyXG4gICAgICAgICAgY2F0ZWdvcnk6ICdwZXJmb3JtYW5jZScsXHJcbiAgICAgICAgICBkb3dubGluazogY29ubmVjdGlvbi5kb3dubGluayxcclxuICAgICAgICAgIGVmZmVjdGl2ZVR5cGU6IGNvbm5lY3Rpb24uZWZmZWN0aXZlVHlwZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVjb3JkTWV0cmljKG5hbWU6IHN0cmluZywgdmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLm1ldHJpY3MuZ2V0KG5hbWUpIHx8IFtdO1xyXG4gICAgZXhpc3RpbmcucHVzaCh2YWx1ZSk7XHJcbiAgICBcclxuICAgIC8vIEtlZXAgb25seSBsYXN0IDEwMCBtZWFzdXJlbWVudHNcclxuICAgIGlmIChleGlzdGluZy5sZW5ndGggPiAxMDApIHtcclxuICAgICAgZXhpc3Rpbmcuc2hpZnQoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5tZXRyaWNzLnNldChuYW1lLCBleGlzdGluZyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHRyaWdnZXJBbGVydChhbGVydFR5cGU6IHN0cmluZywgdmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3QgYWxlcnQgPSB0aGlzLmFsZXJ0cy5nZXQoYWxlcnRUeXBlKTtcclxuICAgIGlmIChhbGVydCAmJiB2YWx1ZSA+IGFsZXJ0LnRocmVzaG9sZCkge1xyXG4gICAgICBhbGVydC5jYWxsYmFjaygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlbmQgYWxlcnQgdG8gYW5hbHl0aWNzXHJcbiAgICBhbmFseXRpY3MudHJhY2tFdmVudCgncGVyZm9ybWFuY2VfYWxlcnQnLCB7XHJcbiAgICAgIGNhdGVnb3J5OiAnbW9uaXRvcmluZycsXHJcbiAgICAgIGFsZXJ0X3R5cGU6IGFsZXJ0VHlwZSxcclxuICAgICAgdmFsdWVcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2V0QWxlcnQoYWxlcnRUeXBlOiBzdHJpbmcsIHRocmVzaG9sZDogbnVtYmVyLCBjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgdGhpcy5hbGVydHMuc2V0KGFsZXJ0VHlwZSwgeyB0aHJlc2hvbGQsIGNhbGxiYWNrIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0TWV0cmljcygpOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXJbXT4ge1xyXG4gICAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXJbXT4gPSB7fTtcclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMubWV0cmljcy5lbnRyaWVzKCkpIHtcclxuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBnZXRBdmVyYWdlTWV0cmljKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLm1ldHJpY3MuZ2V0KG5hbWUpIHx8IFtdO1xyXG4gICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPiAwID8gdmFsdWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gdmFsdWVzLmxlbmd0aCA6IDA7XHJcbiAgfVxyXG5cclxuICAvLyBIZWFsdGggY2hlY2sgbWV0aG9kXHJcbiAgZ2V0SGVhbHRoU3RhdHVzKCkge1xyXG4gICAgY29uc3QgbWVtb3J5VXNhZ2UgPSB0aGlzLmdldEF2ZXJhZ2VNZXRyaWMoJ21lbW9yeV91c2FnZScpO1xyXG4gICAgY29uc3QgbG9hZFRpbWUgPSB0aGlzLmdldEF2ZXJhZ2VNZXRyaWMoJ3BhZ2VfbG9hZF90aW1lJyk7XHJcbiAgICBjb25zdCBlcnJvclJhdGUgPSB0aGlzLmdldEF2ZXJhZ2VNZXRyaWMoJ2phdmFzY3JpcHRfZXJyb3JzJyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhdHVzOiB0aGlzLmNhbGN1bGF0ZUhlYWx0aFN0YXR1cyhtZW1vcnlVc2FnZSwgbG9hZFRpbWUsIGVycm9yUmF0ZSksXHJcbiAgICAgIG1ldHJpY3M6IHtcclxuICAgICAgICBtZW1vcnlfdXNhZ2U6IG1lbW9yeVVzYWdlLFxyXG4gICAgICAgIHBhZ2VfbG9hZF90aW1lOiBsb2FkVGltZSxcclxuICAgICAgICBlcnJvcl9yYXRlOiBlcnJvclJhdGVcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVIZWFsdGhTdGF0dXMobWVtb3J5OiBudW1iZXIsIGxvYWRUaW1lOiBudW1iZXIsIGVycm9yczogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGlmIChtZW1vcnkgPiAxMDAgfHwgbG9hZFRpbWUgPiA1MDAwIHx8IGVycm9ycyA+IDUpIHJldHVybiAnY3JpdGljYWwnO1xyXG4gICAgaWYgKG1lbW9yeSA+IDUwIHx8IGxvYWRUaW1lID4gMzAwMCB8fCBlcnJvcnMgPiAyKSByZXR1cm4gJ3dhcm5pbmcnO1xyXG4gICAgcmV0dXJuICdoZWFsdGh5JztcclxuICB9XHJcblxyXG4gIHN0b3BNb25pdG9yaW5nKCk6IHZvaWQge1xyXG4gICAgdGhpcy5pc01vbml0b3JpbmcgPSBmYWxzZTtcclxuICAgIC8vIENsZWFuIHVwIGFueSBpbnRlcnZhbHMgb3Igb2JzZXJ2ZXJzIGhlcmVcclxuICB9XHJcblxyXG4gIC8vIE1lbW9yeSBtb25pdG9yaW5nIHV0aWxpdHlcclxuICBwcml2YXRlIG1vbml0b3JNZW1vcnkoKSB7XHJcbiAgICBpZiAoJ21lbW9yeScgaW4gcGVyZm9ybWFuY2UpIHtcclxuICAgICAgY29uc3QgbWVtb3J5ID0gKHBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5O1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZWQ6IE1hdGgucm91bmQobWVtb3J5LnVzZWRKU0hlYXBTaXplIC8gMTA0ODU3NiksXHJcbiAgICAgICAgdG90YWw6IE1hdGgucm91bmQobWVtb3J5LnRvdGFsSlNIZWFwU2l6ZSAvIDEwNDg1NzYpLFxyXG4gICAgICAgIGxpbWl0OiBNYXRoLnJvdW5kKG1lbW9yeS5qc0hlYXBTaXplTGltaXQgLyAxMDQ4NTc2KVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgbW9uaXRvcmluZyA9IG5ldyBNb25pdG9yaW5nU2VydmljZSgpO1xyXG4iXSwibmFtZXMiOlsiYW5hbHl0aWNzIiwiTW9uaXRvcmluZ1NlcnZpY2UiLCJzdGFydE1vbml0b3JpbmciLCJpc01vbml0b3JpbmciLCJpbml0aWFsaXplTW9uaXRvcmluZyIsIm1vbml0b3JQZXJmb3JtYW5jZSIsIm1vbml0b3JFcnJvcnMiLCJtb25pdG9yVXNlckJlaGF2aW9yIiwibW9uaXRvclJlc291cmNlcyIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJsb2FkVGltZSIsInBlcmZvcm1hbmNlIiwidGltaW5nIiwibG9hZEV2ZW50RW5kIiwibmF2aWdhdGlvblN0YXJ0IiwicmVjb3JkTWV0cmljIiwidHJpZ2dlckFsZXJ0Iiwib2JzZXJ2ZXIiLCJQZXJmb3JtYW5jZU9ic2VydmVyIiwibGlzdCIsImVudHJ5IiwiZ2V0RW50cmllcyIsImVudHJ5VHlwZSIsIm5hdkVudHJ5IiwiZmV0Y2hTdGFydCIsIm9ic2VydmUiLCJlbnRyeVR5cGVzIiwiZXZlbnQiLCJ0cmFja0Vycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiZmlsZW5hbWUiLCJsaW5lbm8iLCJjb2xubyIsIlN0cmluZyIsInJlYXNvbiIsInR5cGUiLCJlbmdhZ2VtZW50U3RhcnQiLCJEYXRlIiwibm93IiwiaXNFbmdhZ2VkIiwicmVzZXRFbmdhZ2VtZW50IiwiZW5nYWdlbWVudFRpbWUiLCJ0aHJvdHRsZSIsImZ1bmMiLCJsaW1pdCIsImluVGhyb3R0bGUiLCJzZXRUaW1lb3V0IiwiZm9yRWFjaCIsImRvY3VtZW50Iiwic2V0SW50ZXJ2YWwiLCJtZW1vcnkiLCJtb25pdG9yTWVtb3J5IiwidXNlZCIsIm5hdmlnYXRvciIsImNvbm5lY3Rpb24iLCJkb3dubGluayIsInRyYWNrRXZlbnQiLCJjYXRlZ29yeSIsImVmZmVjdGl2ZVR5cGUiLCJuYW1lIiwidmFsdWUiLCJleGlzdGluZyIsIm1ldHJpY3MiLCJnZXQiLCJwdXNoIiwibGVuZ3RoIiwic2hpZnQiLCJzZXQiLCJhbGVydFR5cGUiLCJhbGVydCIsImFsZXJ0cyIsInRocmVzaG9sZCIsImNhbGxiYWNrIiwiYWxlcnRfdHlwZSIsInNldEFsZXJ0IiwiZ2V0TWV0cmljcyIsInJlc3VsdCIsImtleSIsImVudHJpZXMiLCJnZXRBdmVyYWdlTWV0cmljIiwidmFsdWVzIiwicmVkdWNlIiwiYSIsImIiLCJnZXRIZWFsdGhTdGF0dXMiLCJtZW1vcnlVc2FnZSIsImVycm9yUmF0ZSIsInN0YXR1cyIsImNhbGN1bGF0ZUhlYWx0aFN0YXR1cyIsIm1lbW9yeV91c2FnZSIsInBhZ2VfbG9hZF90aW1lIiwiZXJyb3JfcmF0ZSIsInRpbWVzdGFtcCIsImVycm9ycyIsInN0b3BNb25pdG9yaW5nIiwiTWF0aCIsInJvdW5kIiwidXNlZEpTSGVhcFNpemUiLCJ0b3RhbCIsInRvdGFsSlNIZWFwU2l6ZSIsImpzSGVhcFNpemVMaW1pdCIsIk1hcCIsIm1vbml0b3JpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./services/monitoringService.ts\n"));

/***/ })

});